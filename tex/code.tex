\section{图论}

\subsection{最短路径}
\subsubsection{Dijkstra}
\begin{lstlisting}
const int maxn = 1e4;
const int inf = 0x3f3f3f3f;

//d数组用来记录源点s到顶点i的最短距离
//v表示该顶点是否在顶点集S中
//g邻接矩阵存图，g[i][j]表示i到j的边的权值，无边时为inf
//n为顶点数量
int d[maxn], v[maxn];
int g[maxn][maxn];
int n;
void dij(int s)
{
	memset(v, 0, sizeof(v));
	for(int i=1;i<=n;i++)
	d[i] = g[s][i];
	v[s] = 1;
	for(int i=1;i<=n;i++)
	{
		int u = 0;
		for(int j=1;j<=n;j++)
		{
			if(!v[j] && (u==0 || d[j] < d[u]))
				u = j;
		}
		if(u==0)return ;
		v[u] = 1;
		for(int j=1;j<=n;j++)
		{
			d[j] = min(d[j], d[u]+g[u][j]);
		}
	}
}
\end{lstlisting}

\subsubsection{Dijkstra优化}
\begin{lstlisting}
const int maxn = 1e4;
const int inf = 0x3f3f3f3f;
typedef pair<int, int> P; //first表示最短距离，second表示顶点编号
//边：to表示这条边指向的顶点，权值为w
struct Edge
{
	int to, w;
};
//用vector实现邻接表
vector<Edge> g[maxn];
int d[maxn]; //记录源点到顶点i的最短距离
int n;

void dij(int s)
{
	priority_queue<P, vector<P>, greater<P> > q;
	memset(d, inf, sizeof(d));
	d[s] = 0;
	q.push(P(0, s));
	while(!q.empty())
	{
		P p = q.top();
		q.pop();
		int u = p.second;
		if(d[u] < p.first) continue;
		for(int i=0; i<g[u].size(); i++)
		{
			Edge e = g[u][i];
			if(d[e.to] > d[u] + e.w)
			{
				d[e.to] = d[u] + e.w;
				q.push(P(d[e.to], e.to));
			}
		}
	}
}
\end{lstlisting}

\subsubsection{Floyd}
\begin{lstlisting}
int g[maxn][maxn];
int n;
void floyd()
{
	for(int k=1;k<=n;k++)
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				g[i][j] = min(g[i][j], g[i][k] + g[k][j]);
}
\end{lstlisting}

\subsubsection{Bellman-Ford}
\begin{lstlisting}
const int maxn = 1e4;
const int inf = 0x3f3f3f3f; //常用于表示无穷大

//边结构体，记录u->v的边，权值为w
struct Edge
{
	int u, v, w;
	Edge(int uu, int vv, int ww) { u=uu; v=vv; w=ww; }
	Edge(){}
}e[maxn];
int edgecnt; // 边的数量
//加边操作
void addEdge(int u, int v, int w)
{
	e[edgecnt++] = Edge(u, v, w);
}

int n; //顶点总数
int d[maxn]; //记录最短距离的数组

//存在负权回路则返回true，否则返回false
bool bellman_ford(int s)
{
	memset(d, inf, sizeof(d));
	d[s] = 0;
	//进行n-1次松弛操作,第n次检查是否含有负权回路
	for(int i=1;i<=n;i++)
	{
		int flag = 0;
		for(int j=0; j<edgecnt; j++)
		{
			Edge t = e[j];
			int u, v, w;
			u = t.u; v = t.v; w = t.w;
			if(d[v] > d[u] + w)
			{
				d[v] = d[u] + w;
				flag = 1;
			}
		}
		if(!flag) return false;
		if(i==n && flag) return true;
	}
	return false;
}
\end{lstlisting}

\subsubsection{SPFA}
\begin{lstlisting}
const int maxn = 1e4;
const int inf = 0x3f3f3f3f; //常用于表示无穷大

//边结构体，to表示边指向的顶点编号，权值为w
struct Edge
{
	int to, w;
	Edge(int tt, int ww) { to = tt; w = ww; }
	Edge(){}
};
//vector实现的邻接表
vector<Edge> g[maxn];
int n;//顶点数
//d表示最短距离， inq[i]表示结点是否在队列中，为1则在，cnt[i]记录i入队的次数
int d[maxn], inq[maxn], cnt[maxn];
//初始化
void init()
{
	memset(d, inf, sizeof(d));
	memset(inq, 0, sizeof(inq));
	memset(cnt, 0, sizeof(cnt));
}
//返回true表示存在负权回路
bool spfa(int s)
{
	init();
	d[s] = 0;
	inq[s] = 1;
	cnt[s] = 1;
	queue<int> q;
	q.push(s);
	while(!q.empty())
	{
		int u = q.front();
		inq[u] = 0;
		q.pop();
		for(int i=0;i < g[u].size(); i++)
		{
			Edge e = g[u][i];
			if(d[e.to] > d[u] + e.w)
			{
				d[e.to] = d[u] + e.w;
				if(inq[e.to] == 0)
				{
					inq[e.to] = 1;
					q.push(e.to);
					cnt[e.to]++;
					if(cnt[e.to] > n) return true;
				}
			}
		}
	}
	return true;
}
\end{lstlisting}

\subsection{次短路}
\begin{lstlisting}
#include <bits/stdc++.h>
#define INF 1e16+100
#define ms(x,y) memset(x,y,sizeof(x))
using namespace std;

typedef long long ll;
typedef pair<ll,ll> P;

const double pi = acos(-1.0);
const int mod = 1e9 + 7;
const int maxn = 1e5 + 5;

struct Edge{
	ll to,cost;
};

ll n,m;
vector<Edge> a[maxn];
ll dist[maxn],dist2[maxn];

void addedge(ll u,ll v,ll w)
{
	a[u].push_back(Edge{v,w});
	a[v].push_back(Edge{u,w});
}

void solve()
{
	priority_queue<P, vector<P>, greater<P> >que;
	//ms(dist,INF);
	//ms(dist2,INF);
	fill(dist,dist+n,INF);
	fill(dist2,dist2+n,INF);
	dist[0]=0;
	que.push(P(0,0));
	while(que.size())
	{
		P u=que.top();que.pop();
		int v=u.second;
		ll d=u.first;
		if(dist2[v]<d) continue;	//不是次短距离则抛弃
		for(int i=0;i<a[v].size();i++)
		{
			Edge e=a[v][i];
			ll d2=d+e.cost;
			if(dist[e.to]>d2)	//更新最短
			{
				swap(dist[e.to],d2);
				que.push(P(dist[e.to],e.to));
			}
			if(dist2[e.to]>d2&&dist[e.to]<d2)	//更新次短
			{
				dist2[e.to]=d2;
				que.push(P(dist2[e.to],e.to));
			}
		}
	}
	printf("%lld\n",dist2[n-1]);
}

int main()
{
	//freopen("in.txt","r",stdin);
	//freopen("out.txt","w",stdout);
	int t;
	scanf("%d",&t);
	while(t--)
	{
		scanf("%lld%lld",&n,&m);
		for(int i=0;i<n;i++) a[i].clear();
		for(int i=0;i<m;i++)
		{
			ll p,q,w;
			scanf("%lld%lld%lld",&p,&q,&w);
			addedge(p-1,q-1,w);
		}
		solve();
	}
	return 0;
}
\end{lstlisting}

\subsection{LCA}
\subsubsection{倍增}
\begin{lstlisting}
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define inf 0x3f3f3f3f
typedef pair<int, int> P;
const int maxn = 5e5+5;
const ll mod = 1e9+7;

vector<int> son[maxn]; // 存储儿子顶点
// dep[i]表示顶点i的深度，n个顶点，m个询问，rt为树根，fa数组用来预处理顶点i向上跳2^j步之后的顶点
int dep[maxn], n, m, rt, fa[maxn][20];
int v[maxn]={0}; // 是否访问标记

// pre是父顶点，rt是当前顶点
void dfs(int pre, int rt)
{
	dep[rt] = dep[pre]+1; // 当前顶点的深度为父顶点加一
	fa[rt][0] = pre; // 当前顶点向上跳一步为父顶点
	v[rt] = 1; // 访问
	// dp预处理
	for(int i=1;i<=19;i++)
	fa[rt][i] = fa[fa[rt][i-1]][i-1];
	// 继续dfs
	for(int i=0;i<son[rt].size();i++)
	if(v[son[rt][i]]==0)
	dfs(rt, son[rt][i]);
}

// 求解LCA(a, b)
int lca(int a, int b)
{
	if(dep[a] < dep[b])
		swap(a, b);
	for(int i=19;i>=0;i--)
	{
		if(dep[a]-dep[b] >= (1<<i))
		{
			a = fa[a][i];
		}
	}
	if(a==b)return a;
	for(int i=19;i>=0;i--)
	{
		if(fa[a][i] != fa[b][i])
		{
			a = fa[a][i];
			b = fa[b][i];
		}
	}
	return fa[a][0];
}

int main()
{
	scanf("%d%d%d", &n, &m, &rt);
	for(int i=1;i<n;i++)
	{
		int a, b;
		scanf("%d%d", &a, &b);
		son[a].push_back(b);
		son[b].push_back(a);
	}
	memset(fa, 0, sizeof(fa));
	memset(dep, inf, sizeof(dep));
	v[0]=1;
	dep[0] = 0;
	dfs(0, rt);
	for(int i=1;i<=m;i++)
	{
		int a, b;
		scanf("%d%d", &a, &b);
		printf("%d\n", lca(a, b));
	}
	return 0;
}
\end{lstlisting}

\subsubsection{RMQ}
\begin{lstlisting}
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define inf 0x3f3f3f3f
typedef pair<int, int> P;
const int maxn = 5e5+5;
const ll mod = 1e9+7;

vector<int> g[maxn]; // 存图
// dep记录DFS序中每一个顶点的深度， vis记录DFS序， id记录顶点i第一次在DFS序中的位置， st表
int dep[maxn<<1]={0}, vis[maxn<<1]={0}, id[maxn]={0}, st[maxn<<1][25];
// dfs序计数用，看代码能理解
int dfs_c=1;

// 父顶点为pre， 当前顶点为now， 当前深度为d
void dfs(int pre, int now, int d)
{
	id[now] =  dfs_c; // now顶点在DFS序中第一次出现的位置是dfs_c
	dep[dfs_c] = d; // 记录now的深度
	vis[dfs_c++] = now; // DFS序中第dfs_c个顶点是now，同时将dfs_c加一
	for(int i=0;i<g[now].size();i++)
	{
		if(g[now][i]!=pre)
		{
			dfs(now, g[now][i], d+1);
			vis[dfs_c] = now;
			dep[dfs_c++] = d;
		}
	}
}

// 预处理st表
void getSt(int n)
{
	for(int i=1;i<=n;i++)
	st[i][0] = i;
	for(int j=1; (1<<j)<=n; j++)
	{
		for(int i=1;i+(1<<j)<=n; i++)
		{
			int a = st[i][j-1], b = st[i+(1<<(j-1))][j-1];
			if(dep[a] < dep[b])
				st[i][j] = a;
			else st[i][j] = b;
		}
	}
}

// 查询DFS序中区间[l, r]深度最小的顶点在DFS序中的位置
int query(int l, int r)
{
	int k = log2(r-l+1);
	int a = st[l][k];
	int b = st[r-(1<<k)+1][k];
	// 返回深度较小的那一个顶点在DFS序中的位置
	if(dep[a]<dep[b])return a;
	else return b;
}

// 求LCA(a, b)
int lca(int a, int b)
{
	int x, y;
	x = id[a], y = id[b];
	if(x>y)return vis[query(y, x)];
	else return vis[query(x, y)];
}

// 检查用的
void check(int n)
{
	for(int i=1;i<=dfs_c;i++)cout<<dep[i]<<" ";cout<<"\n\n";
	for(int i=1;i<=dfs_c;i++)cout<<vis[i]<<" ";cout<<"\n\n";
	for(int i=1;i<=n;i++)cout<<id[i]<<" ";cout<<"\n\n";
}

int main()
{
	int n, m, rt;
	scanf("%d%d%d", &n, &m, &rt);
	for(int i=1;i<n;i++)
	{
		int a, b;
		scanf("%d%d", &a, &b);
		g[a].push_back(b);
		g[b].push_back(a);
	}
	dfs(0, rt, 1);
	getSt(dfs_c);
	//check(n);
	for(int i=1;i<=m;i++)
	{
		int a, b;
		scanf("%d%d", &a, &b);
		printf("%d\n", lca(a, b));
	}
	return 0;
}
\end{lstlisting}


\subsection{强连通分量}
\begin{lstlisting}
vector<int> g[maxn];
int low[maxn], dfn[maxn], sta[maxn], ins[maxn], belong[maxn];
int cnt, ind, tot; //cnt：强连通分量的数量， ind：时间戳， tot：sta的top

void init()
{
	memset(ins, 0, sizeof(ins));
	memset(belong, 0, sizeof(belong));
	memset(dfn, 0, sizeof(dfn));
	cnt = ind = tot = 0;
}

void Tarjan(int u)
{
	low[u] = dfn[u] = ++ind;
	ins[u] = 1;
	sta[++tot] = u;
	for(int i=0;i<g[u].size();i++)
	{
		int v = g[u][i];
		if(!dfn[v])
		{
			Tarjan(v);
			low[u] = min(low[u], low[v]);
		}
		else if(ins[v])
		low[u] = min(low[u], dfn[v]);
	}
	int p;
	if(low[u] == dfn[u])
	{
		++cnt;
		do
		{
			p = sta[tot--];
			belong[p] = cnt;
			ins[p] = 0;
		}while(p != u);
	}
}
\end{lstlisting}

\subsection{割点}
\begin{lstlisting}
vector<int> g[maxn];
// iscut[i]: 若顶点i是割点，则为1，反之为0
int low[maxn], dfn[maxn], iscut[maxn];
int ind;

void init()
{
	memset(dfn, 0, sizeof(dfn));
	memset(iscut, 0, sizeof(iscut));
	ind = 0;
}

// pa为u的父节点，初始时Tarjan(i, i)
void Tarjan(int u, int pa)
{
	int cnt = 0; //用来记录子树的数量
	low[u] = dfn[u] = ++ind;
	for(int i=0;i<g[u].size();i++)
	{
		int v = g[u][i];
		if(!dfn[v])
		{
			Tarjan(v, u);
			low[u] = min(low[u], low[v]);
			// 若low[v]>=dfn[u]，并且u不是根节点，则u是割点
			if(low[v] >= dfn[u] && pa!=u)
			iscut[u] = 1;
			// 若u是根节点，则cnt++
			if(u == pa)
				cnt++;
		}
		else if(v != pa) //若v不等于父节点
		low[u] = min(low[u], dfn[v]);
	}
	if(cnt>=2 && u==pa) //根节点子树数量大于等于2，则为割点
		iscut[u] = 1;
}
\end{lstlisting}

\subsection{桥}
\begin{lstlisting}
// 用链式前向星来存储边
struct Edge
{
	// iscut表示是否为桥
	int to, next, iscut;
}e[maxn*maxn*2];

int head[maxn], low[maxn], dfn[maxn];
int ind, tot; // tot是边的数量

void init()
{
	memset(head, -1, sizeof(head));
	memset(dfn, 0, sizeof(dfn));
	ind = tot = 0;
}

void addedge(int u, int v)
{
	e[tot].to = v;
	e[tot].next = head[u];
	e[tot].iscut = 0;
	head[u] = tot++;
}

void Tarjan(int u, int pa)
{
	low[u] = dfn[u] = ++ind;
	for(int i=head[u]; ~i; i = e[i].next)
	{
		int v = e[i].to;
		if(v == pa) continue;
		if(!dfn[v])
		{
			Tarjan(v, u);
			low[u] = min(low[u], low[v]);
			// 是桥
			if(low[v] > dfn[u])
			{
				e[i].iscut = e[i^1].iscut = 1;
			}
		}
		else
		{
			low[u] = min(low[u], dfn[v]);
		}
	}
}
\end{lstlisting}


\subsection{最大流}
\subsubsection{Dinic}
\begin{lstlisting}
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int, int> P;
const int maxn = 1e6+5;
const int inf = 0x3f3f3f3f;
const int mod = 1e9+7;

// 用链式前向星来存储图
struct ed
{
	int to, val, ne;
}edge[maxn<<1];
int head[maxn], dep[maxn];
// 顶点数n，边数m，源点s，汇点e，加边时的指针tot
int n, m, s, e, tot;

void init()
{
	tot = -1;
	memset(head, -1, sizeof(head));
}

void addEdge(int u, int v, int val)
{
	edge[++tot].to = v;
	edge[tot].val = val;
	edge[tot].ne = head[u];
	head[u] = tot;
}

// 就是最普通的bfs
int bfs()
{
	memset(dep, -1, sizeof(dep));
	dep[s] = 0;
	queue<int> q;
	q.push(s);
	while(!q.empty())
	{ 
		int u = q.front();
		q.pop();
		for(int i=head[u]; ~i; i=edge[i].ne)
		{
			int v = edge[i].to;
			if(dep[v]==-1 && edge[i].val>0)
			{
				dep[v] = dep[u]+1;
				q.push(v);
			}
		}
	}
	return (dep[e] != -1); //若dep[e]==-1则表示没有可以到达e的增广路了，算法结束。
}

// 当前顶点u，当前流量flow
// 初始时dfs(s, inf)
int dfs(int u, int flow)
{
	if(u == e)return flow;
	for(int i=head[u]; ~i; i=edge[i].ne)
	{
		int v = edge[i].to;
		if(dep[v]==dep[u]+1 && edge[i].val)
		{
			int a = dfs(v, min(flow, edge[i].val));
			if(a>0) //若找到增广路
			{
				edge[i].val -= a;
				edge[i^1].val += a;
				return a;
			}        
		}
	}
	return 0;
}

ll dinic()
{
	ll ans = 0;
	while(bfs())
	{
		int a = dfs(s, (1<<30));
		ans += a;
	}
	return ans;
}

int main()
{
	scanf("%d%d%d%d", &n, &m, &s, &e);
	init();
	for(int i=1;i<=m;i++)
	{
		int u, v, w;
		scanf("%d%d%d", &u, &v, &w);
		addEdge(u, v, w);
		addEdge(v, u, 0); //反边
	}
	printf("%lld\n", dinic());
	return 0;
}
\end{lstlisting}

\subsubsection{Dinic优化}
\begin{lstlisting}
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int, int> P;
const int maxn = 1e6+5;
const int inf = 0x3f3f3f3f;
const int mod = 1e9+7;

struct ed
{
	int to, val, ne;
}edge[maxn<<1];
int head[maxn],dep[maxn], cur[maxn];
int n, m, s, e, tot;

void init()
{
	tot = -1;
	memset(head, -1, sizeof(head));
}

void addEdge(int u, int v, int val)
{
	edge[++tot].to = v;
	edge[tot].val = val;
	edge[tot].ne = head[u];
	head[u] = tot;
}

int bfs()
{
	memset(dep, -1, sizeof(dep));
	dep[s] = 0;
	queue<int> q;
	q.push(s);
	while(!q.empty())
	{ 
		int u = q.front();
		q.pop();
		for(int i=head[u]; ~i; i=edge[i].ne)
		{
			int v = edge[i].to;
			if(dep[v]==-1 && edge[i].val>0)
			{
				dep[v] = dep[u]+1;
				q.push(v);
			}
		}
	}
	return (dep[e] != -1);
}

int dfs(int u, int flow)
{
	if(u == e)return flow;
	// rflow用于多路增广，表示流入到顶点u的剩余未流出的流量
	int rflow = flow;
	// 当前弧优化，通过引用，可以改变cur[i]的值，使得下次遍历到顶点u时，会直接从上次增广的边开始遍历
	for(int& i=cur[u]; ~i; i=edge[i].ne)
	{
		int v = edge[i].to;
		if(dep[v]==dep[u]+1 && edge[i].val)
		{
			int a = dfs(v, min(rflow, edge[i].val));
			edge[i].val -= a;
			edge[i^1].val += a;
			rflow -= a; // 剩余流量要减少
			if(rflow<=0)break; // 若没有剩余流量了，就break
		}
	}
	// 若没有一丝流量流出，则表示通过顶点u已经无法增广了，于是炸点，dep可以设置为任何无意义值
	if(rflow == flow)
	dep[u] = -2;
	return flow - rflow; // 返回流出的流量
}

ll dinic()
{
	ll ans = 0;
	while(bfs())
	{
		// 新一轮dfs之前要对cur进行初始化
		for(int i=1;i<=n;i++)cur[i] = head[i];
		int a = dfs(s, (1<<30));
		ans += a;
	}
	return ans;
}

int main()
{
	scanf("%d%d%d%d", &n, &m, &s, &e);
	init();
	for(int i=1;i<=m;i++)
	{
		int u, v, w;
		scanf("%d%d%d", &u, &v, &w);
		addEdge(u, v, w);
		addEdge(v, u, 0);
	}
	printf("%lld\n", dinic());
	return 0;
}
\end{lstlisting}


\subsection{二分图匹配}
\subsubsection{匈牙利算法}
\begin{lstlisting}
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int, int> P;
const int maxn = 1e3+5;
const int inf = 0x3f3f3f3f;
const int mod = 1e9+7;


int mp[maxn][maxn];
int use[maxn], link[maxn];
int n, m, e, ans;

int found(int u)
{
	for(int i=1;i<=m;i++)
	{
		if(!use[i] && mp[u][i])
		{
			use[i] = 1;
			if(!link[i] || found(link[i]))
			{
				link[i] = u;
				return 1;
			}
		}
	}
	return 0;
}

int main()
{
	scanf("%d%d%d", &n, &m, &e);
	for(int i=1;i<=e;i++)
	{
		int u, v;
		scanf("%d%d", &u, &v);
		if(u<=n && v<=m)
		{
			mp[u][v] = 1;
		}
	}
	for(int i=1;i<=n;i++)
	{
		memset(use, 0, sizeof(use));
		if(found(i))ans++;
	}
	printf("%d\n", ans);
	return 0;
}
\end{lstlisting}


\subsection{最小生成树}
\subsubsection{Prim}
\begin{lstlisting}
const int MAX=10000007;
int dis[5002],map[5002][5002],mark[5002];
int prim(int n)
{
	for(int i=1;i<=n;i++)  //初始化每个点到生成树中点的距离
	{
		dis[i]=map[1][i];
		mark[i]=0;
	}
	dis[1]=0;
	mark[1]=1; //1这个点加入生成树中。
	int sum=0;
	for(int i=1;i<n;i++) //枚举n-1条边
	{
		int sta=-1,Min=MAX;
		for(int j=1;j<=n;j++)  //找不在生成树中的点中距离生成树中的点长度最小的
		{
			if(!mark[j]&&dis[j]<Min)
			{
				Min=dis[j];
				sta=j;
			}
		}
		if(sta==-1) return -1; //没找到可以可以联通的路
		mark[sta]=1;   //新找到的点加入生成树
		sum+=Min;
		for(int j=1;j<=n;j++)  //更新树外的点到树中的点的距离
		{
			if(!mark[j]&&dis[j]>map[sta][j])
			dis[j]=map[sta][j];
		}
	}
	return sum;
}

int main()
{
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			map[i][j]=MAX;
		}
	}
	for(int i=1;i<=m;i++)
	{
		int a,b,c;
		cin>>a>>b>>c;
		if(c<map[a][b])
		{
			map[a][b]=c;
			map[b][a]=c;
		}
	}
	int ans = prim(n);
	if(ans==-1)
		cout<<"orz"<<endl;
	else
		cout<<ans<<endl;
	return 0;
}
\end{lstlisting}


\subsubsection{kruskal}
\begin{lstlisting}
#include<bits/stdc++.h>
using namespace std;
#define N 5005
int father[N];

int find(int x)
{
	int k = x;
	while(father[k]!=k)
	{
		k = father[k];
	}
	while(father[x]!=x)
	{
		int temp = x;
		x = father[x];
		father[temp] = k;
	}
	return k;
}

void join(int a, int b)
{
	int f1, f2;
	f1 = find(a);
	f2 = find(b);
	father[f1] = f2;
}

struct edge
{
	int node1, node2;
	int cost;
};

vector<edge> edges;

bool cmp(edge a, edge b)
{
	return a.cost > b.cost;
}

int kruskal(int n)
{
	sort(edges.begin(), edges.end(), cmp);
	for(int i=1;i<=n;i++)
		father[i] = i;
	int sum=0;
	while(n!=1 && !edges.empty())
	{
		edge temp = edges[edges.size()-1];
		edges.pop_back();
		if(find(temp.node1)!=find(temp.node2))
		{
			sum += temp.cost;
			n--;
			join(temp.node1, temp.node2);
		}
	}
	if(n!=1 && edges.empty())
		sum = -1;
	return sum;
}

int main()
{
	int n,m;
	int result;
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int a,b,c;
		cin>>a>>b>>c;
		edge t;
		t.node1=a;t.node2=b;t.cost=c;
		edges.push_back(t);
	}
	result = kruskal(n);
	if(result == -1)
		cout<<"orz"<<endl;
	else
		cout<<result<<endl;
	return 0;
}
\end{lstlisting}

\subsection{次小生成树-POJ1679}
\begin{lstlisting}
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define inf 0x3f3f3f3f
typedef pair<int, int> P;
const int maxn = 110;
const ll mod = 1e9+7;

int n, m;
int g[maxn][maxn];
int d[maxn], v[maxn], maxd[maxn][maxn], pre[maxn], mst[maxn][maxn];
int ans = 0;

void prim()
{
	for(int i=1;i<=n;i++)
	{
		v[i] = 0; d[i] = inf; pre[i] = 1;
	}
	memset(maxd, 0, sizeof(maxd));
	memset(mst, 0, sizeof(mst));
	ans = 0;
	priority_queue<P, vector<P>, greater<P> > q;
	d[1] = 0; q.push(P(0, 1));
	while(!q.empty())
	{
		P p = q.top(); q.pop();
		int u = p.second;
		if(v[u]) continue;
		v[u] = 1; ans += d[u];
		mst[pre[u]][u] = mst[u][pre[u]] = 1;
		for(int i=1; i<=n;i++)
		{
			if(v[i] && g[u][i] < inf)
				maxd[u][i] = maxd[i][u] = max(maxd[pre[u]][u], d[u]);
			if(d[i] > g[u][i])
			{
				d[i] = g[u][i];
				pre[i] = u;
				q.push(P(d[i], i));
			}
		}
	}
}

int main()
{
	int t;
	cin>>t;
	while(t--)
	{
		memset(g, inf, sizeof(g));
		cin>>n>>m;
		while(m--)
		{
			int a, b, c;
			cin>>a>>b>>c;
			g[a][b] = g[b][a] = c;
		}
		prim();
		int flag = 0;
		for(int i=1;i<=n&&!flag;i++)
		{
			for(int j=1;j<=n;j++)
			{
				if(mst[i][j] || g[i][j]==inf)continue;
				if(g[i][j] == maxd[i][j])
				{
					flag = 1;
					break;
				}
			}
		}
		if(flag) cout<<"Not Unique!"<<endl;
		else cout<<ans<<endl;
	}
	return 0;
}
\end{lstlisting}

\subsection{拓扑排序}
\begin{lstlisting}
#include<bits/stdc++.h>
using namespace std;
const int maxn=30;

int head[maxn],ip,indegree[maxn];
int n,m,seq[maxn];

struct note
{
	int v,next;
}edge[maxn*maxn];

void init()
{
	memset(head,-1,sizeof(head));
	ip=0;
}

void addedge(int u,int v)
{
	edge[ip].v=v,edge[ip].next=head[u],head[u]=ip++;
}

int topo()
{
	queue<int>q;
	int indeg[maxn];
	for(int i=0; i<n; i++)
	{
		indeg[i]=indegree[i];
		if(indeg[i]==0)
		q.push(i);
	}
	int k=0;
	bool res=false;
	while(!q.empty())
	{
		if(q.size()!=1)res=true;
		int u=q.front();
		q.pop();
		seq[k++]=u;
		for(int i=head[u]; i!=-1; i=edge[i].next)
		{
			int v=edge[i].v;
			indeg[v]--;
			if(indeg[v]==0)
				q.push(v);
		}
	}
	if(k<n)return -1;// no
	if(res)return 0;// more
	return 1; // only
}
\end{lstlisting}

\subsection{Floyd找最小环}
\begin{lstlisting}
const int INF = 0x3f3f3f3f;
const int MAXN = 110;

int n, m;               //  n:节点个数, m:边的个数
int g[MAXN][MAXN];      //  无向图
int dist[MAXN][MAXN];   //  最短路径
int r[MAXN][MAXN];      //  r[i][j]: i到j的最短路径的第一步
int out[MAXN], ct;      //  记录最小环

int solve(int i, int j, int k)
{   //  记录最小环
	ct = 0;
	while (j != i)
	{
		out[ct++] = j;
		j = r[i][j];
	}
	out[ct++] = i;
	out[ct++] = k;
	return 0;
}

int main()
{
	while (scanf("%d%d", &n, &m) != EOF)
	{
		int i, j, k;
		for (i = 0; i < n; i++)
		{
			for (j = 0; j < n; j++)
			{
				g[i][j] = INF;
				r[i][j] = i;
			}
		}
		for (i = 0; i < m; i++)
		{
			int x, y, l;
			scanf("%d%d%d", &x, &y, &l);
			--x;
			--y;
			if (l < g[x][y])
			{
				g[x][y] = g[y][x] = l;
			}
		}
		memmove(dist, g, sizeof(dist));
		int Min = INF;              //  最小环
		for (k = 0; k < n; k++)
		{                           //  Floyd
			for (i = 0; i < k; i++) //  一个环中的最大结点为k(编号最大)
			{
				if (g[k][i] < INF)
				{
					for (j = i + 1; j < k; j++)
					{
						if (dist[i][j] < INF && g[k][j] < INF && Min > dist[i][j] + g[k][i] + g[k][j])
						{
							Min = dist[i][j] + g[k][i] + g[k][j];
							solve(i, j, k);     //  记录最小环
						}
					}
				}
			}
			for (i = 0; i < n; i++)
			{
				if (dist[i][k] < INF)
				{
					for (j = 0; j < n; j++)
					{
						if (dist[k][j] < INF && dist[i][j] > dist[i][k]+dist[k][j])
						{
							dist[i][j] = dist[i][k] + dist[k][j];
							r[i][j] = r[k][j];
						}
					}
				}
			}
		}
		if (Min < INF)
		{
			for (ct--; ct >= 0; ct--)
			{
				printf("%d", out[ct] + 1);
				if (ct)
				{
					printf(" ");
				}
			}
		}
		else
		{
			printf("No solution.");
		}
		printf("\n");
	}
	return 0;
}
\end{lstlisting}

\subsection{生成树计数(基尔霍夫矩阵) BZOJ1002}
\begin{lstlisting}
// f[i] = 3*f[i-1] - f[i-2] + 2
// 需要高精度
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> P;
const int maxn = 1e6+5;
const int inf = 0x3f3f3f3f;
const int mod = 1e9+7;
const double PI = acos(-1);


struct node
{
	int a[101], len;
};
node f[101];
node mul(node a, int k)
{
	for(int i=1;i<=a.len;i++)
		a.a[i]*=k;
	for(int i=1;i<=a.len;i++)
	{
		a.a[i+1]+=a.a[i]/10;
		a.a[i]%=10;
	}
	while(a.a[a.len+1]!=0)a.len++;
	return a;
}

node sub(node a, node b)
{
	a.a[1] += 2;
	int j = 1;
	while(a.a[j]>=10)
	{
		a.a[j]%=10;
		a.a[j+1]++;
		j++;
	}
	for(int i=1;i<=a.len;i++)
	{
		a.a[i] -= b.a[i];
		if(a.a[i]<0)
		{
			a.a[i]+=10;
			a.a[i+1]--;
		}
	}
	while(a.a[a.len]==0)a.len--;
	return a;
}

int main()
{
	f[1].a[1] = 1; f[2].a[1] = 5;
	f[1].len = f[2].len = 1;
	int n;
	scanf("%d", &n);
	for(int i=3;i<=n;i++)
		f[i] = sub(mul(f[i-1], 3), f[i-2]);
	for(int i=f[n].len;i>0;i--)
		printf("%d", f[n].a[i]);
	printf("\n");
	return 0;
}
\end{lstlisting}

\subsection{悬线法 BZOJ3039}
\begin{lstlisting}
// 悬线法求最大子矩阵
// 给定n*m的矩阵，含F和R，求最大的全F矩阵的面积×3

#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> P;
const int maxn = 1e3+5;
const int inf = 0x3f3f3f3f;
const ll INF = 0x3f3f3f3f3f3f3f3f;
const int mod = 1e9+7;
const double PI = acos(-1);


char mp[maxn][maxn];
int l[maxn][maxn], r[maxn][maxn], h[maxn][maxn];
int n, m;

int main()
{
	ios::sync_with_stdio(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cin>>mp[i][j];
		}
	}
	for(int i=1;i<=n;i++)
	{
		int tmp = 1;
		for(int j=1;j<=m;j++)
		{
			if(mp[i][j] == 'F')
			{
				l[i][j] = tmp;
				if(mp[i-1][j]=='F')
					l[i][j] = max(l[i][j], l[i-1][j]);
			}
			else tmp = j+1;
		}
	}
	for(int i=1;i<=n;i++)
	{
		int tmp = m;
		for(int j=m;j>=1;j--)
		{
			if(mp[i][j]=='F')
			{
				r[i][j] = tmp;
				if(mp[i-1][j] == 'F')
					r[i][j] = min(r[i][j], r[i-1][j]);
			}
			else tmp = j-1;
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(mp[i][j] == 'F')
			h[i][j] = h[i-1][j]+1;
		}
	}
	int ans = 0;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(mp[i][j]=='F')
				ans = max(ans, h[i][j]*(r[i][j]-l[i][j]+1));
		}
	}
	cout<<3*ans<<endl;
	return 0;
}
\end{lstlisting}

\subsection{欧拉回路}
\begin{lstlisting}
int head[N];
struct edgenode{
	int to;
	int next;
}tu[N];
int ans[maxn];///maxn是边的最大数量
bool vis[maxn];
int bj=0;
void dfs(int now)
{
	for(int i=head[now];i!=-1;i=tu[i].next)
	if(!vis[i])
	{
		vis[i]=1;
		vis[i^1]=1;///这里是求欧拉回路，这一题用不着写这句，因为可以走双向
		dfs(tu[i].to);
		ans[bj++]=i;///等于i是记录边，等于tu[i].to是记录点
	}
}

// 或者

struct Edge
{
	int v;
	bool vis;
	Edge(){}
	Edge(int v,bool vis):v(v),vis(vis){}
}edges[maxm*2];
vector<Edge>G[maxn];
vector<int> ans;
void init()
{
	for (int i = 0;i<=n;i++)
		G[i].clear();
}
void euler(int u)
{
	for (int i = 0;i<G[u].size();i++)
	{
		Edge &e = G[u][i];
		if (!e.vis)
		{
			e.vis=1;
			euler(e.v);
		}
	}
	ans.push_back(u);
	//printf("%d\n",u);
}
\end{lstlisting}


\section{数据结构}
\subsection{并查集}
\begin{lstlisting}
int pre[maxn];

int Find(int x)
{
	int p,tmp;
	p=x;
	while(x!=pre[x])
		x=pre[x];
	while(p!=x)
	{
		tmp=pre[x];
		pre[x]=x;
		p=tmp;
	}
	return x;
}

void join(int x,int y)
{
	int fx=Find(x);
	int fy=Find(y);
	if(fx!=fy)
		pre[fx]=fy;
}
\end{lstlisting}
\subsection{带权并查集}
\subsubsection{BZOJ1202}
\begin{lstlisting}
\\ 给出n个月份，每个月份都有营业额
\\ m个判断，表示区间[l, r]的和为w
\\ 判断是否有矛盾
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> P;
const int maxn = 1e3+5;
const int inf = 0x3f3f3f3f;
const ll INF = 0x3f3f3f3f3f3f3f3f;
const int mod = 1e9+7;
const double PI = acos(-1);



int n, m;
int fa[105], d[105];
int find(int x)
{
	if(fa[x]==x)return x;
	int xx = find(fa[x]);
	d[x] += d[fa[x]];
	return fa[x] = xx;
}
int main()
{
	int t;
	scanf("%d", &t);
	while(t--)
	{
		scanf("%d%d", &n, &m);
		memset(d, 0, sizeof(d));
		for(int i=0;i<=n;i++) fa[i] = i;
		int f = 1;
		while(m--)
		{
			int s, t ,w;
			scanf("%d%d%d", &s, &t, &w);
			s--;
			int fas = find(s), fat = find(t);
			if(fas != fat)
			{
				fa[fat] = fas;
				d[fat] = d[s]+w-d[t];
			}
			else if(d[t]-d[s]!=w)f=0;
		}
		if(f)printf("true\n");
		else printf("false\n");
	}
	return 0;
}
\end{lstlisting}

\subsection{ST表}
\begin{lstlisting}
int st[maxn][20];
void st_init()
{
	for(int i=1;i<=n;i++) st[i][0]=a[i]; // 长度为1的区间最小值党委就为自身
	// 预处理从i开始，长度为2^j的区间
	for(int j=1;(1<<j)<=n;j++)
		for(int i=1;i+(1<<j)-1<=n;i++)
			st[i][j]=max(st[i][j-1],st[i+(1<<(j-1))][j-1]);
}

int query(int l,int r)
{
	int k=log2(r-l+1);
	return min(st[l][k],st[r-(1<<k)+1][k]);
}
\end{lstlisting}


\subsection{树状数组}
\begin{lstlisting}
/*
*  INIT: ar[]置为0;
*  CALL: add(i, v): 将i点的值加v; sum(i): 求[1, i]的和;
*/
#define typev int   //  type of res
const int N = 1010;
typev ar[N];        //  index: 1 ~ N
int lowb(int t)
{
	return t & (-t);
}

void add(int i, typev v)
{
	for (; i < N; ar[i] += v, i += lowb(i));
	return ;
}

typev sum(int i)
{
	typev s = 0;
	for (; i > 0; s += ar[i], i -= lowb(i));
	return s;
}
\end{lstlisting}

\subsection{线段树}
\subsubsection{单点修改+区间求和 HDU1166}
\begin{lstlisting}
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

int num[50005];
ll tree[4 * 50000 + 5];

void build(int p, int l, int r)
{
	if(l == r)
	{
		tree[p] = num[l];
		return ;
	}
	else
	{
		int mid = (r+l) >> 1;
		build(p<<1, l, mid);
		build(p<<1|1, mid+1, r);
		tree[p] = tree[p<<1] + tree[p<<1|1];
	}
}

void add(int p, int l, int r, int ind, int v)
{
	if(l == r)
	{
		tree[p] += v;
		return ;
	}
	else
	{
		int mid = (r+l) >> 1;
		if(ind <= mid) add(p<<1, l, mid, ind, v);
		else add(p<<1|1, mid+1, r, ind, v);
		tree[p] = tree[p<<1] + tree[p<<1|1];
	}
}

ll query(int p, int l, int r, int x, int y)
{
	if(x <= l && r <= y)
	{
		return tree[p];
	}
	else
	{
		int mid = (l+r) >> 1;
		ll ans = 0;
		if(x <= mid)
			ans += query(p<<1, l, mid, x, y);
		if(mid < y)
			ans += query(p<<1|1, mid+1, r, x, y);
		return ans;
	}
}

int main()
{
	int t;
	scanf("%d", &t);
	for(int i=1;i<=t;i++)
	{
		int n;
		scanf("%d", &n);
		for(int j=1;j<=n;j++)
			scanf("%d", &num[j]);
		build(1, 1, n);
		string s;
		printf("Case %d:\n", i);
		while(cin>>s && s[0] != 'E')
		{
			if(s[0] == 'Q')
			{
				int x, y;
				scanf("%d%d", &x, &y);
				printf("%lld\n", query(1, 1, n, x, y));
			}
			else if(s[0] == 'A')
			{
				int x, y;
				scanf("%d%d", &x, &y);
				add(1, 1, n, x, y);
			}
			else
			{
				int x, y;
				scanf("%d%d", &x, &y);
				add(1, 1, n, x, -y);
			}
		}
	}
	return 0;
}
\end{lstlisting}


\subsubsection{区间修改+区间求和 POJ3465}
\begin{lstlisting}
#include<iostream>
using namespace std;
typedef long long ll;
ll num[100005];
ll tree[4 * 100000 + 5];
ll lazy[4 * 100000 + 5]={0};
int n,m;
void build(int p, int l, int r)
{
	if(l == r)
	tree[p] = num[l];
	else
	{
		int mid = (l+r) >> 1;
		build(p<<1, l, mid);
		build(p<<1|1, mid+1, r);
		tree[p]  = tree[p<<1] + tree[p<<1|1];
	}
}

void pushdown(int p, int l, int r)
{
	if(lazy[p])
	{
		lazy[p<<1] += lazy[p];
		lazy[p<<1|1] += lazy[p];
		tree[p<<1] += lazy[p] * (((l+r)>>1) - l + 1);
		tree[p<<1|1] += lazy[p] * (r - ((l+r)>>1));
		lazy[p] = 0;
	}
}

void add(int p, int l, int r, int x, int y, ll v)
{
	if(x <= l && r <= y)
	{
		lazy[p] += v;
		tree[p] += v * (r-l+1);
		return ;
	}
	else
	{
		int mid = (l+r) >> 1;
		pushdown(p, l, r);
		if(x <= mid)
			add(p<<1, l, mid, x, y, v);
		if(y > mid)
			add(p<<1|1, mid+1, r, x, y, v);
		tree[p] = tree[p<<1] + tree[p<<1|1];
	}
}

ll query(int p, int l, int r, int x, int y)
{
	if(x <= l && r <= y)
	{
		return tree[p];
	}
	else
	{
		int mid = (l+r) >> 1;
		ll ans = 0;
		pushdown(p, l, r);
		if(x <= mid)
			ans += query(p<<1, l, mid, x, y);
		if(y > mid)
			ans += query(p<<1|1, mid+1, r, x, y);
		return ans;
	}
}

int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	cin>>num[i];
	build(1, 1, n);
	for(int i=1;i<=m;i++)
	{
		char a;
		cin>>a;
		if(a == 'Q')
		{
			int x, y;
			cin>>x>>y;
			cout<<query(1, 1, n, x, y)<<endl;
		}
		else
		{
			int x, y;
			ll c;
			cin>>x>>y>>c;
			add(1, 1, n, x, y, c);
		}
	}
	return 0;
}
\end{lstlisting}

\subsubsection{单点修改+区间最值 HDU1754}
\begin{lstlisting}
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int n,m;

int num[200005];
int tree[200000 * 4 + 5];

void build(int p, int l, int r)
{
	if(l == r)
	{
		tree[p] = num[l];
		return ;
	}
	else
	{
		int mid = (l+r) >> 1;
		build(p<<1, l, mid);
		build(p<<1|1, mid+1, r);
		tree[p] = max(tree[p<<1], tree[p<<1|1]);
		return ;
	}
}

void update(int p, int l, int r, int ind, int v)
{
	if(l == r)
	{
		tree[p] = v;
		return ;
	}
	else
	{
		int mid = (l+r) >> 1;
		if(ind <= mid)
			update(p<<1, l, mid, ind, v);
		else
			update(p<<1|1, mid+1, r, ind, v);
		tree[p] = max(tree[p<<1], tree[p<<1|1]);
	}
}

ll query(int p, int l, int r, int x, int y)
{
	if(x <= l && r <= y)
	{
		return tree[p];
	}
	else
	{
		int mid = (l+r) >> 1;
		ll ans = -1;
		if(x <= mid)
			ans = max(ans, query(p<<1, l, mid, x, y));
		if(y > mid)
			ans = max(ans, query(p<<1|1, mid+1, r, x, y));
		return ans;
	}
}

int main()
{
	while(scanf("%d %d", &n, &m) != EOF)
	{
		for(int i=1;i<=n;i++)
		{
			scanf("%d", &num[i]);
		}
		build(1, 1, n);
		for(int i=1;i<=m;i++)
		{
			char a;
			int x, y;
			scanf(" %c%d%d", &a, &x, &y);
			if(a == 'Q')
			{
				printf("%lld\n", query(1, 1, n, x, y));
			}
			else
			{
				update(1, 1, n, x, y);
			}
		}
	}
	return 0;
}
\end{lstlisting}


\subsubsection{区间染色+统计+离散化 POJ2528}
\begin{lstlisting}
#include<iostream>
#include<algorithm>
#include<string.h>
using namespace std;
typedef long long ll;

const int maxn = 20000 + 100;
int tree[maxn<<4];
int li[maxn],ri[maxn];
bool vis[maxn];
int lisan[maxn*3];
int ans = 0;

void init()
{
	memset(tree, -1, sizeof(tree));
	memset(vis, 0, sizeof(vis));
	ans = 0;
}

void pushdown(int p)
{
	tree[p<<1] = tree[p<<1|1] = tree[p];
	tree[p] = -1;
}

void update(int p, int l, int r, int x, int y, int v)
{
	if(x <= l && r <= y)
	{
		tree[p] = v;
		return ;
	}
	if(tree[p]!=-1)
		pushdown(p);
	int mid = (l+r)>>1;
	if(x <= mid)
		update(p<<1, l, mid, x, y, v);
	if(y > mid)
		update(p<<1|1, mid+1, r, x, y, v);
	tree[p] = -1;
}

void query(int p, int l, int r)
{
	if(tree[p]!=-1)
	{
		if(vis[tree[p]]==0)
		{
			vis[tree[p]] = 1;
			ans++;
		}
		return;
	}
	if(l==r)return;
	int mid = (l+r)>>1;
	query(p<<1, l, mid);
	query(p<<1|1, mid+1, r);
}

int main()
{
	int t;
	cin>>t;
	while(t--)
	{
		init();
		int n;
		cin>>n;
		int tot = 0;
		for(int i=0;i<n;i++)
		{
			cin>>li[i]>>ri[i];
			lisan[tot++] = li[i];
			lisan[tot++] = ri[i];
		}
		sort(lisan, lisan+tot);
		int m = unique(lisan, lisan+tot) - lisan;
		int t = m;
		for(int i=1;i<t;i++)
		{
			if(lisan[i]-lisan[i-1]>1)
			{
				lisan[m++] = lisan[i-1]+1;
			}
		}
		sort(lisan, lisan+m);
		for(int i=0;i<n;i++)
		{
			int x,y;
			x = lower_bound(lisan, lisan+m, li[i]) - lisan;
			y = lower_bound(lisan, lisan+m, ri[i]) - lisan;
			update(1, 0, m-1, x, y, i);
		}
		query(1, 0, m-1);
		cout<<ans<<endl;
	}
	return 0;
}
\end{lstlisting}

\subsubsection{线段树+扫描线求矩阵覆盖周长 POJ1177}
\begin{lstlisting}
#include<iostream>
#include<vector>
#include<algorithm>
#include<cmath>
using namespace std;
typedef long long ll;

const int maxn = 10005;
vector<int> x;
int getID(int v)
{
	return lower_bound(x.begin(), x.end(), v) - x.begin();
}

struct Segment
{
	int l, r;
	int h;
	int flag;
}segment[maxn];
bool cmp(Segment a, Segment b)
{
	return a.h < b.h;
}

struct Node
{
	int l,r;
	int lr, rr;
	int len;
	int line;
	int s;
}node[maxn<<2];

void build(int p, int l, int r)
{
	node[p].l = l; node[p].r = r;
	node[p].line = node[p].len = node[p].s = 0;
	node[p].lr = node[p].rr = 0;
	if(l==r)return;
	int mid = (l+r)>>1;
	build(p<<1, l, mid);
	build(p<<1|1, mid+1, r);
}

void pushup(int p)
{
	if(node[p].s)
	{
		node[p].line = 1;
		node[p].rr = node[p].lr = 1;
		node[p].len = x[node[p].r+1] - x[node[p].l];
		return;
	}
	else if(node[p].l == node[p].r)
	{
		node[p].lr = node[p].rr = node[p].line = node[p].len = 0;
	}
	else
	{
		node[p].lr = node[p<<1].lr;
		node[p].rr = node[p<<1|1].rr;
		node[p].len = node[p<<1].len + node[p<<1|1].len;
		node[p].line = node[p<<1].line + node[p<<1|1].line - (node[p<<1].rr&&node[p<<1|1].lr);
	}
}

void update(int p, int l, int r, int v)
{
	if(node[p].r < l || node[p].l > r)return;
	if(l <= node[p].l && node[p].r <= r)
	{
		node[p].s += v;
		pushup(p);
		return;
	}
	update(p<<1, l, r, v);
	update(p<<1|1, l, r, v);
	pushup(p);
}

int main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		int x1,x2,y1,y2;
		cin>>x1>>y1>>x2>>y2;
		Segment &s1 = segment[2*i-1];
		Segment &s2 = segment[i<<1];
		s1.l = s2.l = x1;
		s1.r = s2.r = x2;
		s1.h = y1; s2.h = y2;
		s1.flag = 1; s2.flag = -1;
		x.push_back(x1);
		x.push_back(x2);
	}
	sort(segment+1, segment+2*n+1, cmp);

	sort(x.begin(), x.end());
	x.erase(unique(x.begin(), x.end()), x.end());

	build(1, 0, x.size()-1);

	ll ans = 0;
	int last = 0;
	for(int i=1;i<=2*n;i++)
	{
		int l = getID(segment[i].l);
		int r = getID(segment[i].r);
		update(1, l, r-1, segment[i].flag);
		ans += abs(node[1].len - last);
		if(i!=2*n)
			ans += node[1].line * 2 * (segment[i+1].h - segment[i].h);
		last = node[1].len;
	}
	cout<<ans<<endl;
	return 0;
}
\end{lstlisting}

\subsubsection{线段树+扫描线求矩阵面积并 HDU1542}
\begin{lstlisting}
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

const int maxn = 210;
int n;
vector<double> x;
inline int getID(double v)
{
	return lower_bound(x.begin(), x.end(), v) - x.begin();
}

struct Segment
{
	double l, r;
	double h;
	int flag;
}segment[maxn];
bool cmp(Segment a, Segment b)
{
	return a.h < b.h;
}

struct Node
{
	int l, r;
	int s;
	double len;
}node[maxn<<2];

void pushup(int p)
{
	if(node[p].s)
		node[p].len = x[node[p].r+1] - x[node[p].l];
	else if(node[p].l == node[p].r)
		node[p].len = 0;
	else
		node[p].len = node[p<<1].len + node[p<<1|1].len;
}

void build(int p, int l, int r)
{
	if(l>r)return;
	node[p].l = l; node[p].r = r;
	node[p].s = 0; node[p].len = 0;
	if(l==r) return;
	int mid = (l+r)>>1;
	build(p<<1, l, mid);
	build(p<<1|1, mid+1, r);
	pushup(p);
}

void update(int p, int l, int r, int v)
{
	if(l>node[p].r || r<node[p].l) return;
	if(l <= node[p].l && node[p].r <= r)
	{
		node[p].s += v;
		pushup(p);
		return;
	}
	update(p<<1, l, r, v);
	update(p<<1|1, l, r, v);
	pushup(p);
}

int main()
{
	int cas = 0;
	while(scanf("%d", &n) && n)
	{
		x.clear();
		for(int i=1;i<=n;i++)
		{
			double x1,x2,y1,y2;
			scanf("%lf%lf%lf%lf", &x1, &y1, &x2, &y2);
			Segment &s1 = segment[2*i-1];
			Segment &s2 = segment[i<<1];
			s1.l=s2.l=x1;
			s1.r=s2.r=x2;
			s1.h=y1;
			s2.h=y2;
			s1.flag=1;
			s2.flag=-1;
			x.push_back(x1);
			x.push_back(x2);
		}
		sort(segment+1, segment+2*n+1, cmp);

		sort(x.begin(), x.end());
		x.erase(unique(x.begin(), x.end()), x.end());

		build(1, 0, x.size()-1);
		double ans = 0;
		for(int i=1;i<=2*n;i++)
		{
			int l=getID(segment[i].l);
			int r=getID(segment[i].r);
			update(1, l, r-1, segment[i].flag);
			ans+=node[1].len*(segment[i+1].h - segment[i].h);
		}
		printf("Test case #%d\n", ++cas);
		printf("Total explored area: %.2f\n\n", ans);
	}
	return 0;
}
\end{lstlisting}
\subsubsection{状压+线段树维护区间26字母种类 CF1234D}
\begin{lstlisting}
/*
* 操作1：将原pos位置的字母改为字母c
* 操作2：查询区间[l, r]的字母种类数
*/

#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int, int> P;
const int maxn = 1e5+5;
const int inf = 0x3f3f3f3f;
const int mod = 1e9+7;

char s[maxn];
const int N=1e5+5;
struct fun{
	bitset<270>bit;
}tree[N<<2],v[N<<2];



void sett(int l,int r,int rt){  // 建树
	if(l==r){
		tree[rt].bit=0;
		tree[rt].bit.set(s[l]-'a');
		return ;
	}
	int mid=(l+r)>>1;
	sett(l,mid,rt<<1);
	sett(mid+1,r,rt<<1|1);
	tree[rt].bit=(tree[rt<<1].bit|tree[rt<<1|1].bit);
}

void fun(int l,int r,int rt){    // 下推
	if(v[rt].bit.count()){        // 统计 bit 中 1 的个数
		v[rt<<1].bit=v[rt].bit;
		v[rt<<1|1].bit=v[rt].bit;
		tree[rt<<1].bit=tree[rt].bit;
		tree[rt<<1|1].bit=tree[rt].bit;
		v[rt].bit=0;             // 记得清零
	}
}

void upset(int x,int y,int vel,int l,int r,int rt){
	if(x<=l&&y>=r){
		v[rt].bit.set(vel);
		tree[rt].bit=0;
		tree[rt].bit.set(vel);
		return ;
	}
	fun(l,r,rt);
	int mid=l+r>>1;
	if(x<=mid) upset(x,y,vel,l,mid,rt<<1);
	if(y>mid) upset(x,y,vel,mid+1,r,rt<<1|1);
	tree[rt].bit=(tree[rt<<1].bit|tree[rt<<1|1].bit);
}
bitset<270>bb(0);
void findd(int x,int y,int l,int r,int rt){
	if(x<=l&&y>=r){
		bb|=tree[rt].bit;
		return ;
	}

	fun(l,r,rt);
	int mid=l+r>>1;
	if(x<=mid)
		findd(x,y,l,mid,rt<<1);
	if(y>mid)
		findd(x,y,mid+1,r,rt<<1|1);
}


int main()
{
	int q;
	int op;
	int l, r;
	char ch;
	int ind;
	int n;
	scanf("%s", s+1);
	n = strlen(s+1);
	scanf("%d", &q);
	sett(1, n, 1);
	while(q--)
	{
		scanf("%d", &op);
		if(op==1)
		{
			scanf("%d ", &ind);
			ch = getchar();
			upset(ind, ind, ch-'a', 1, n, 1);
		}
		else
		{
			scanf("%d%d", &l, &r);
			bb = 0;
			findd(l, r, 1, n, 1);
			printf("%d\n", bb.count());
		}
	}
	return 0;
}
\end{lstlisting}

\subsection{主席树}
\subsubsection{区间第K大}
\begin{lstlisting}
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define inf 0x3f3f3f3f
typedef pair<int, int> P;
const int maxn = 1e6+5;
const ll mod = 1e9+7;

// 顶点，代表区间[l, r]中有v个数字
struct node
{
	int l, r, v;
}tree[maxn*20]; // 空间开大一点，因为要动态开点

// edit[i]存的是第i颗权值线段树的根节点在tree数组中的位置
// a是存放原数据的数组， b是离散化后的数组， tot表示顶点的个数
int edit[maxn], a[maxn], b[maxn], tot=0;

// 建树
int build(int l, int r)
{
	// 这里就是动态开辟新的结点，就是将tot加一
	int pos = ++tot;
	tree[pos].v = 0; //初始化为0
	if(l==r)return pos; //到根节点了，返回
	// 二分建树没什么好说的
	int mid = (l+r)>>1;
	tree[pos].l = build(l, mid);
	tree[pos].r = build(mid+1, r);
	//要返回pos的位置，因为edit数组要存新根的位置
	return pos;
}

// 就是插入操作，插入新的元素
// ed是前一版本的结点在tree的位置， 更新区间[l, r]， 位置为v
int update(int ed, int l, int r, int v)
{
	// 动态开点
	int pos = ++tot;
	//先将新一版本的当前结点复制为上一个版本的对应结点
	tree[pos] = tree[ed]; tree[pos].v++; //新一版本的结点的v要加一，因为对应区间插入了一个数
	if(l==r) return pos; //到叶子节点了，返回
	// 二分
	int mid = (l+r)>>1;
	// 如果更新位置v在左子树中，递归更新即可，在右子树中同理，最后要返回pos
	if(v<=mid) tree[pos].l = update(tree[ed].l, l, mid, v);
	else tree[pos].r = update(tree[ed].r, mid+1, r, v);
	return pos;
}

// 查询区间[l, r]第k大的数字，pre对应l-1版本的权值线段树的节点位置， ed代表r版本的权值线段树的节点位置
int query(int pre, int ed, int l, int r, int k)
{
	// 到叶子节点就返回
	if(l==r) return l;
	// 二分
	int mid = (l+r)>>1;
	// 先计算左子树的数字个数
	int x = tree[tree[ed].l].v - tree[tree[pre].l].v;
	// 若左子树的数字个数大于等于k，说明我们要找的数字在左子树中，递归走到左子树继续寻找
	if(x>=k) return query(tree[pre].l, tree[ed].l, l, mid, k);
	// 否则就在右子树中，我们要在右子树中寻找k-x大的数字，递归寻找就好
	else return query(tree[pre].r, tree[ed].r, mid+1, r, k-x);
}

int main()
{
	int n, q; // n个数字， q次询问
	scanf("%d%d", &n, &q); // 这一题cin/cout会被卡
	// 输入数据，并copy到b数组中
	for(int i=1;i<=n;i++)
	{
		scanf("%d", &a[i]);
		b[i] = a[i];
	}
	// 离散化
	sort(b+1, b+1+n);
	int m = unique(b+1, b+n+1) - b-1;
	// 构建一颗空的权值线段树，edit[0]存放的就是这颗空树的根节点的位置
	edit[0] = build(1, m);
	// 插入n个数据
	for(int i=1;i<=m;i++)
	{
		// 找到a[i]离散化后对应的位置
		a[i] = lower_bound(b+1, b+m+1, a[i]) - b;
		// edit[i]存放第i版本的权值线段树的根节点位置
		edit[i] = update(edit[i-1], 1, m, a[i]);
	}
	// 处理q次询问
	while(q--)
	{
		int x, y, k;
		scanf("%d%d%d", &x, &y, &k);
		// pos对应的是离散化后的位置，所以最后输出b[pos]即可
		int pos = query(edit[x-1], edit[y], 1, m, k);
		printf("%d\n", b[pos]);
	}
	return 0;
}
\end{lstlisting}


\subsubsection{动态区间第K大(主席树套树状数组) ZOJ2112}
\begin{lstlisting}
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define inf 0x3f3f3f3f
typedef pair<int, int> P;
const int maxn = 60010;
const ll mod = 1e9+7;
const int M = 2500010;

int n, m, q, tot;
struct node
{
	int l, r, v;
}tree[M];

// T是主席树，与上面代码的edit作用一样， S数组就是树状数组， use数组是树状数组求和时用的，记录的是树状数组中哪一些权值线段树要被用来求和
int T[maxn], S[maxn], use[maxn], a[maxn], b[maxn];

// 记录询问，因为要将修改后的值一起构建主席树，所以将在线转为离线
struct Q
{
	// 对于查询区间[l, r]第k大的询问来说，flag为1
	//若是修改操作，l记录修改的位置，r记录新值，flag为0
	int l, r, k, flag;
}query[10010];

// 快速找出x在离散化后的位置
int HASH(int x)
{
	return lower_bound(b+1, b+m+1, x) - b;
}

// 建静态主席树，和之前的一样
int build(int l, int r)
{
	int pos = ++tot;
	tree[pos].v = 0;
	if(l==r) return pos;
	int mid = (l+r)>>1;
	tree[pos].l = build(l, mid);
	tree[pos].r = build(mid+1, r);
	return pos;
}

// 和之前的静态主席树update差不多，只不过不是直接将tree[pos].v+1,而是加参数v
//消除影响v就为-1， 添加影响v就为1， 其他没什么不同
int update(int ed, int l, int r, int p, int v)
{
	int pos = ++tot;
	tree[pos] = tree[ed];
	tree[pos].v += v;
	if(l==r) return pos;
	int mid = (l+r)>>1;
	if(p<=mid) tree[pos].l = update(tree[ed].l, l, mid, p, v);
	else tree[pos].r = update(tree[ed].r, mid+1, r, p, v);
	return pos;
}

// 树状数组的lowbit
int lowbit(int x) { return x&(-x); }

// 修改操作，修改位置x的影响
int add(int x, int v)
{
	// 找出a[x]在离散化后的位置p
	int p = HASH(a[x]);
	while(x<=n)
	{
		// 修改操作，对树状数组中相应的权值线段树进行修改，消除影响：v=-1， 添加影响：v=1
		// 因为树状数组中的权值线段树不需要可持久化，所以直接在原版本上修改就可以了
		S[x] = update(S[x], 1, m, p, v);
		x+=lowbit(x);
	}
}

// 树状数组求和， 求左子树包含的数字个数，和静态主席树一样的思想，都是先求左子树
int sum(int x)
{
	int ret = 0;
	while(x)
	{
		// use[i]记录的就是树状数组中相应的权值线段树的结点位置
		// 似乎这一句有一点点难以理解，结合整体代码多看几遍吧
		ret += tree[tree[use[x]].l].v;
		x-=lowbit(x);
	}
	return ret;
}

// 询问操作。树状数组求[pre, ed]的和， tpre和ted是静态主席树的区间左右顶点的位置， 区间[l, r]第k大
int Query(int pre, int ed, int tpre, int ted, int l, int r, int k)
{
	if(l==r)return l;
	int mid = (l+r)>>1;
	// sum就是树状数组的求和，相对于静态主席树，多了sum求修改操作的影响
	// tmp为当前左子树的数字个数
	int tmp = sum(ed) - sum(pre) + tree[tree[ted].l].v - tree[tree[tpre].l].v;
	// 若左子树的数字个数大于等于k就往左子树继续走，这里和主席树没什么区别
	if(tmp >= k)
	{
		// 两个for循环是更新左子树需要用到的树状数组中的权值线段树的位置，有那么一丢丢难以理解，多看几遍？
		for(int i=ed; i; i-=lowbit(i)) use[i] = tree[use[i]].l;
		for(int i=pre; i; i-=lowbit(i)) use[i] = tree[use[i]].l;
		return Query(pre, ed, tree[tpre].l, tree[ted].l, l, mid, k);
	}
	else
	{
		// 走右子树同理
		for(int i=ed; i; i-=lowbit(i)) use[i] = tree[use[i]].r;
		for(int i=pre; i; i-=lowbit(i)) use[i] = tree[use[i]].r;
		return Query(pre, ed, tree[tpre].r, tree[ted].r, mid+1, r, k-tmp);
	}
}

int main()
{
	int t; // t个case
	scanf("%d", &t);
	while(t--)
	{
		scanf("%d%d", &n, &q);
		m = tot = 0; // 记得初始化
		for(int i=1;i<=n;i++)
		{
			scanf("%d", &a[i]);
			b[++m] = a[i];
		}
		char op[5];
		for(int i=1;i<=q;i++)
		{
			scanf("%s", op);
			// 查询操作
			if(op[0]=='Q')
			{
				scanf("%d%d%d", &query[i].l, &query[i].r, &query[i].k);
				query[i].flag = 1;
			}
			else
			{
				scanf("%d%d", &query[i].l, &query[i].r);
				b[++m] = query[i].r; // 注意要将修改后的新值加入到待离散化的b数组
				query[i].flag = 0;
			}
		}
		// 离散化
		sort(b+1, b+m+1);
		m = unique(b+1, b+m+1) - b-1;
		// 构建主席树
		T[0] = build(1, m);
		for(int i=1;i<=n;i++)
			T[i] = update(T[i-1], 1, m, HASH(a[i]), 1);
		// 构建树状数组，每一个节点都是一颗空的权值线段树
		for(int i=1;i<=n;i++)
			S[i] = T[0];
		// 离线处理q个询问
		for(int i=1;i<=q;i++)
		{
			if(query[i].flag) // 查询
			{
				// 两个for循环标记区间[l, r]要使用的树状数组中的权值线段树的位置
				for(int j=query[i].r; j; j-=lowbit(j)) use[j] = S[j];
				for(int j=query[i].l-1; j; j-=lowbit(j)) use[j] = S[j];
				printf("%d\n", b[Query(query[i].l-1, query[i].r, T[query[i].l-1], T[query[i].r], 1, m, query[i].k)]);
			}
			else
			{
				// 先消除影响
				add(query[i].l, -1);
				// 在原数组中更新值
				a[query[i].l] = query[i].r;
				//添加新值的影响
				add(query[i].l, 1);
			}
		}
	}
	return 0;
}
\end{lstlisting}

\subsection{Splay}
\begin{lstlisting}
#define ls(x) T[x].ch[0]
#define rs(x) T[x].ch[1]
#define fa(x) T[x].fa
#define root T[0].ch[1]
using namespace std;
const int MAXN=1e5+10,mod=10007,INF=1e9+10;

// fa:父节点 ch[0]:左孩子 ch[1]:右孩子 val:当前结点值 rec:当前值的个数 
// sum:以当前结点为根的子树的结点数
struct node
{
	int fa,ch[2],val,rec,sum;
}T[MAXN];
int tot=0,pointnum=0;
void update(int x){T[x].sum=T[ls(x)].sum+T[rs(x)].sum+T[x].rec;}
int ident(int x){return T[fa(x)].ch[0]==x?0:1;}
void connect(int x,int fa,int how){T[fa].ch[how]=x;T[x].fa=fa;}
void rotate(int x)
{
	int Y=fa(x),R=fa(Y);
	int Yson=ident(x),Rson=ident(Y);
	connect(T[x].ch[Yson^1],Y,Yson);
	connect(Y,x,Yson^1);
	connect(x,R,Rson);
	update(Y);update(x);
}
void splay(int x,int to)
{
	to=fa(to);
	while(fa(x)!=to)
	{
		int y=fa(x);
		if(T[y].fa==to) rotate(x);
		else if(ident(x)==ident(y)) rotate(y),rotate(x);
		else rotate(x),rotate(x);
	}
}
int newnode(int v,int f)
{
	T[++tot].fa=f;
	T[tot].rec=T[tot].sum=1;
	T[tot].val=v;
	return tot;
}
void Insert(int x)
{
	int now=root;
	if(root==0) {newnode(x,0);root=tot;}
	else
	{
		while(1)
		{
			T[now].sum++;
			if(T[now].val==x) {T[now].rec++;splay(now,root);return ;}
			int nxt=x<T[now].val?0:1;
			if(!T[now].ch[nxt])
			{
				int p=newnode(x,now);
				T[now].ch[nxt]=p;
				splay(p,root);return ;
			}
			now=T[now].ch[nxt];
		}       
	}
}
int find(int x)
{
	int now=root;
	while(1)
	{
		if(!now) return 0;
		if(T[now].val==x) {splay(now,root);return now;}
		int nxt=x<T[now].val?0:1;
		now=T[now].ch[nxt];
	}
}
void delet(int x)
{
	int pos=find(x);
	if(!pos) return ;
	if(T[pos].rec>1) {T[pos].rec--,T[pos].sum--;return ;} 
	else
	{
		if(!T[pos].ch[0]&&!T[pos].ch[1]) {root=0;return ;}
		else if(!T[pos].ch[0]) {root=T[pos].ch[1];T[root].fa=0;return ;}
		else
		{
			int left=T[pos].ch[0];
			while(T[left].ch[1]) left=T[left].ch[1];
			splay(left,T[pos].ch[0]);
			connect(T[pos].ch[1],left,1); 
			connect(left,0,1);//
			update(left);
		}
	}
}
// x的排名
int rak(int x)
{
	int now=root,ans=0;
	while(1)
	{
		if(T[now].val==x) return ans+T[T[now].ch[0]].sum+1;
		int nxt=x<T[now].val?0:1;
		if(nxt==1) ans=ans+T[T[now].ch[0]].sum+T[now].rec;
		now=T[now].ch[nxt];
	}
}
// 排名x的数
int kth(int x)
{
	int now=root;
	while(1)
	{
		int used=T[now].sum-T[T[now].ch[1]].sum;
		if(T[T[now].ch[0]].sum<x&&x<=used) {splay(now,root);return T[now].val;}
		if(x<used) now=T[now].ch[0];
		else now=T[now].ch[1],x-=used;
	}
}
int lower(int x)
{
	int now=root,ans=-INF;
	while(now)
	{
		if(T[now].val<x) ans=max(ans,T[now].val);
		int nxt=x<=T[now].val?0:1;//这里需要特别注意 
		now=T[now].ch[nxt];
	}
	return ans;
}
int upper(int x)
{
	int now=root,ans=INF;
	while(now)
	{
		if(T[now].val>x) ans=min(ans,T[now].val);
		int nxt=x<T[now].val?0:1;
		now=T[now].ch[nxt];
	}
	return ans;
}
\end{lstlisting}

\subsection{树链剖分}
\begin{lstlisting}
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> P;
const int maxn = 1e6+5;
const int inf = 0x3f3f3f3f;
const ll INF = 0x3f3f3f3f3f3f3f3f;
const int mod = 1e9+7;
const double PI = acos(-1);


#define ls k<<1
#define rs k<<1|1

ll root = 1;
struct node
{
	ll u,v,w,nxt;
}edge[maxn];
ll head[maxn];
ll num;

inline void addedge(ll x, ll y)
{
	edge[++num].u = x;
	edge[num].v = y;
	edge[num].nxt = head[x];
	head[x] = num;
}

struct Tree
{
	// f是lazy标记, siz是区间大小
	ll l, r, f, w, siz;
}T[maxn<<2];
// a建线段树用，即重新排序后的结点顺序
// b记录输入点权, tot[i]记录顶点i子树的大小, idx记录编号, deep深度
// son记录重儿子, top[i]记录i所在链的起点, fa记录父亲
ll a[maxn], b[maxn], tot[maxn], idx[maxn], deep[maxn];
ll son[maxn], top[maxn], fa[maxn], cnt;

void update(ll k)
{
	T[k].w = T[ls].w + T[rs].w;
}
void pushdown(ll k)
{
	if(!T[k].f)return ;
	T[ls].w += T[k].f * T[ls].siz;
	T[rs].w += T[k].f * T[rs].siz;
	T[ls].f += T[k].f;
	T[rs].f += T[k].f;
	T[k].f = 0;
}
ll dfs1(ll now, ll f, ll dep)
{
	deep[now] = dep;
	tot[now] = 1;
	fa[now] = f;
	ll maxson = -1;
	for(ll i=head[now]; ~i; i=edge[i].nxt)
	{
		if(edge[i].v==f)continue;
		tot[now] += dfs1(edge[i].v, now, dep+1);
		if(tot[edge[i].v]>maxson)
			maxson=tot[edge[i].v], son[now]=edge[i].v;
	}
	return tot[now];
}
void dfs2(ll now, ll topf)
{
	idx[now] = ++cnt;
	a[cnt] = b[now];
	top[now] = topf;
	if(!son[now])return;
	dfs2(son[now], topf);
	for(ll i=head[now]; ~i; i=edge[i].nxt)
		if(!idx[edge[i].v])
			dfs2(edge[i].v, edge[i].v);
}
void build(ll k, ll l, ll r)
{
	T[k].l=l; T[k].r=r; T[k].siz=r-l+1;
	if(l==r)
	{
		T[k].w = a[l];
		return;
	}
	ll mid = (l+r)>>1;
	build(ls, l, mid);
	build(rs, mid+1, r);
	update(k);
}
// 单点修改
void pointadd(ll k, ll pos, ll val)
{
	if(T[k].l == T[k].r)
	{
		T[k].w += val;return;
	}
	pushdown(k);
	ll mid = (T[k].l+T[k].r)>>1;
	if(pos<=mid)pointadd(ls, pos, val);
	if(pos>mid)pointadd(rs, pos, val);
	update(k);
}
// 区间修改
void intervaladd(ll k, ll l, ll r, ll val)
{
	if(l<=T[k].l && T[k].r <= r)
	{
		T[k].w += T[k].siz*val;
		T[k].f += val;
		return ;
	}
	pushdown(k);
	ll mid = (T[k].l + T[k].r)>>1;
	if(l<=mid)intervaladd(ls, l, r, val);
	if(r>mid)intervaladd(rs, l, r, val);
	update(k);
}
// 区间查询
ll intervalask(ll k, ll l, ll r)
{
	ll ans = 0;
	if(l <= T[k].l && T[k].r <= r)
	{
		ans += T[k].w;
		return ans;
	}
	pushdown(k);
	ll mid = (T[k].l + T[k].r)>>1;
	if(l<=mid)ans+=intervalask(ls, l, r);
	if(r>mid)ans+=intervalask(rs, l, r);
	return ans;
}
// 树上x到y的路径权值和
ll treesum(ll x, ll y)
{
	ll ans = 0;
	while(top[x]!=top[y])
	{
		if(deep[top[x]] < deep[top[y]])
			swap(x, y);
		ans += intervalask(1, idx[top[x]], idx[x]);
		x=fa[top[x]];
	}
	if(deep[x]>deep[y])
		swap(x, y);
	ans += intervalask(1, idx[x], idx[y]);
	return ans;
}


int main()
{
	memset(head, -1, sizeof(head));
	ll n, m;
	scanf("%lld%lld", &n, &m);
	for(int i=1;i<=n;i++)
		scanf("%lld", &b[i]);
	for(int i=1;i<n;i++)
	{
		ll x, y;
		scanf("%lld%lld", &x, &y);
		addedge(x, y); addedge(y, x);
	}
	dfs1(root, 0, 1);
	dfs2(root, root);
	build(1, 1, n);
	while(m--)
	{
		ll opt, x, val;
		scanf("%lld",&opt);
		if(opt==1)
		{
			scanf("%lld%lld", &x, &val);
			pointadd(1, idx[x], val);
		}
		else if(opt==2)
		{
			scanf("%lld%lld", &x, &val);
			intervaladd(1, idx[x], idx[x]+tot[x]-1, val);
		}
		else
		{
			scanf("%lld", &x);
			printf("%lld\n", treesum(root, x));
		}
	}
	return 0;
}
\end{lstlisting}

\subsection{可持久化数组}
\begin{lstlisting}
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
#define inf 0x3f3f3f3f
#define INF 0x3f3f3f3f3f3f3f3f
#define IO ios::sync_with_stdio(0)
#define DEBUG(x) cout<<"--->"<<(x)<<endl;
typedef pair<int, int> P;
const ll mod = 1e9+7;
const double eps = 1e-9;
const double PI = acos(-1);
const int maxn = 1e6+5;

struct node {
	int l, r, val;
}tree[maxn * 40];

int root[maxn], a[maxn];
int cnt;

void build(int l, int r, int &now) {
	now = ++cnt;
	if (l == r) {
		tree[now].val = a[l];
		return;
	}
	int mid = (l + r) >> 1;
	build(l, mid, tree[now].l);
	build(mid+1, r, tree[now].r);
}

void modify(int l, int r, int pre, int &now, int pos, int val) {
	now = ++cnt;
	tree[now] = tree[pre];
	if (l == r) {
		tree[now].val = val;
		return ;
	}
	int mid = (l + r) >> 1;
	if (pos <= mid) modify(l, mid, tree[pre].l, tree[now].l, pos, val);
	else modify(mid+1, r, tree[pre].r, tree[now].r, pos, val);
}

int query(int l, int r, int now, int pos) {
	if (l == r) return tree[now].val;
	int mid = (l + r) >> 1;
	if (pos <= mid) return query(l, mid, tree[now].l, pos);
	else return query(mid+1, r, tree[now].r, pos);
}

int main() {
	int n, m;
	scanf("%d%d", &n, &m);
	for (int i=1; i<=n; i++) scanf("%d", &a[i]);
	build(1, n, root[0]);
	for (int i=1; i<=m; i++) {
		int ver, opt;
		scanf("%d%d", &ver, &opt);
		if (opt == 1) {
			int pos, val;
			scanf("%d%d", &pos, &val);
			modify(1, n, root[ver], root[i], pos, val);
		} else {
			int pos;
			scanf("%d", &pos);
			printf("%d\n", query(1, n, root[ver], pos));
			root[i] = root[ver];
		}
	}
	return 0;
}
\end{lstlisting}

\subsection{可持久化并查集}
\begin{lstlisting}
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
#define inf 0x3f3f3f3f
#define INF 0x3f3f3f3f3f3f3f3f
#define IO ios::sync_with_stdio(0)
#define DEBUG(x) cout<<"--->"<<(x)<<endl;
typedef pair<int, int> P;
const ll mod = 1e9+7;
const double eps = 1e-9;
const double PI = acos(-1);
const int maxn = 2e5+5;

struct node {
	int l, r, val;
}tree[maxn * 40 * 2];

int rootfa[maxn], rootdep[maxn];
int cnt, tot;
int n, m;

void build(int l, int r, int &now) {
	now = ++cnt;
	if (l == r) {
		tree[now].val = ++tot;
		return;
	}
	int mid = (l + r) >> 1;
	build(l, mid, tree[now].l);
	build(mid+1, r, tree[now].r);
}

void modify(int l, int r, int pre, int &now, int pos, int val) {
	now = ++cnt;
	tree[now] = tree[pre];
	if (l == r) {
		tree[now].val = val;
		return;
	}
	int mid = (l + r) >> 1;
	if (pos <= mid) modify(l, mid, tree[pre].l, tree[now].l, pos, val);
	else modify(mid+1, r, tree[pre].r, tree[now].r, pos, val);
}

int query(int l, int r, int now, int pos) {
	if (l == r) return tree[now].val;
	int mid = (l + r) >> 1;
	if (pos <= mid) return query(l, mid, tree[now].l, pos);
	else return query(mid+1, r, tree[now].r, pos);
}

int find(int ver, int x) {
	int fx = query(1, n, rootfa[ver], x);
	return fx == x ? x : find(ver, fx);
}

void merge(int ver, int x, int y) {
	x = find(ver-1, x);	// 新版本还未操作，要从上一个版本找
	y = find(ver-1, y);
	if (x == y) {
		rootfa[ver] = rootfa[ver-1];
		rootdep[ver] = rootdep[ver-1];
	} else {
		int depx = query(1, n, rootdep[ver-1], x);
		int depy = query(1, n, rootdep[ver-1], y);
		if (depx < depy) {
			modify(1, n, rootfa[ver-1], rootfa[ver], x, y);
			rootdep[ver] = rootdep[ver-1];
		} else if(depx > depy) {
			modify(1, n, rootfa[ver-1], rootfa[ver], y, x);
			rootdep[ver] = rootdep[ver-1];
		} else {
			modify(1, n, rootfa[ver-1], rootfa[ver], x, y);
			modify(1, n, rootdep[ver-1], rootdep[ver], y, depy+1);
		}
	}
}

int main() {
	scanf("%d%d", &n, &m);
	build(1, n, rootfa[0]);
	for (int i=1; i<=m; i++) {
		int opt;
		scanf("%d", &opt);
		if (opt == 1) {
			int a, b;
			scanf("%d%d", &a, &b);
			merge(i, a, b);
		} else if(opt == 2) {
			int k;
			scanf("%d", &k);
			rootfa[i] = rootfa[k];
			rootdep[i] = rootdep[k];
		} else {
			int a, b;
			scanf("%d%d", &a, &b);
			rootfa[i] = rootfa[i-1];
			rootdep[i] = rootdep[i-1];
			int fa = find(i, a);
			int fb = find(i, b);
			printf("%d\n", (fa == fb ? 1 : 0));
		}
	}
	return 0;
}
\end{lstlisting}


\section{DP}
\subsection{背包}
\begin{lstlisting}
const int MAXN = 10000;
const int SIZE = 100000;

int dp[SIZE];
int volume[MAXN], value[MAXN], c[MAXN];
int n, v;           //  总物品数，背包容量

//  01背包
void ZeroOnepark(int val, int vol)
{
	for (int j = v ; j >= vol; j--)
	{
		dp[j] = max(dp[j], dp[j - vol] + val);
	}
}

//  完全背包
void Completepark(int val, int vol)
{
	for (int j = vol; j <= v; j++)
	{
		dp[j] = max(dp[j], dp[j - vol] + val);
	}
}

//  多重背包
void Multiplepark(int val, int vol, int amount)
{
	if (vol * amount >= v)
	{
		Completepark(val, vol);
	}
	else
	{
		int k = 1;
		while (k < amount)
		{
			ZeroOnepark(k * val, k * vol);
			amount -= k;
			k <<= 1;
		}
		if (amount > 0)
		{
			ZeroOnepark(amount * val, amount * vol);
		}
	}
}

int main()
{
	while (cin >> n >> v)
	{
		for (int i = 1 ; i <= n ; i++)
		{
			cin >> volume[i] >> value[i] >> c[i];      //   费用，价值，数量
		}
		memset(dp, 0, sizeof(dp));
		for (int i = 1; i <= n; i++)
		{
			Multiplepark(value[i], volume[i], c[i]);  
		}
		cout << dp[v] << endl;
	}
	return 0;
}
\end{lstlisting}


\subsection{数位DP}
\subsubsection{HDU 2089 不要62}
\begin{lstlisting}
// 求区间[n, m]中不含4和62的数字个数
// dp[pos][sta]:在第pos位中，前一位是否为6的满足条件的数字个数。
// sta: 0表示前一位不为6, 1:表示前一位为6

#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> P;
const int maxn = 1e6+5;
const int inf = 0x3f3f3f3f;
const int mod = 1e9+7;
const double PI = acos(-1);


int n, m;
int dp[10][2];
int num[10];

int dfs(int pos, int pre, int sta, bool limit)
{
	if(pos==-1)return 1;
	if(!limit && dp[pos][sta]!=-1)return dp[pos][sta];
	int up = limit?num[pos]:9;
	int tmp = 0;
	for(int i=0;i<=up;i++)
	{
		if(pre==6 && i==2)continue;
		if(i==4)continue;
		tmp += dfs(pos-1, i, i==6, limit&&i==num[pos]);
	}
	if(!limit) dp[pos][sta] = tmp;
	return tmp;
}

int slove(int x)
{
	int pos = 0;
	while(x)
	{
		num[pos++] = x%10;
		x/=10;
	}
	return dfs(pos-1, -1, 0, true);
}

int main()
{
	while(~scanf("%d%d", &n, &m) && n && m)
	{
		memset(dp, -1, sizeof(dp));
		printf("%d\n", slove(m) - slove(n-1));
	}
	return 0;
}
\end{lstlisting}

\subsubsection{SCOI 2009 Windy数}
\begin{lstlisting}
// 求区间[l, r]中不含前导零且相邻位之差的绝对值大于等于2的数的个数

#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> P;
const int maxn = 1e6+5;
const int inf = 0x3f3f3f3f;
const int mod = 1e9+7;
const double PI = acos(-1);


ll l, r;
ll a[20], dp[20][20];

ll dfs(int pos, int pre, int sta, bool limit)
{
	if(pos==-1)return 1;
	if(!limit && dp[pos][pre]!=-1)return dp[pos][pre];
	int up = limit ? a[pos] : 9;
	ll ans= 0;
	for(int i=0;i<=up;i++)
	{
		if(sta!=0)
		{
			ans += dfs(pos-1, i, sta&&(i==0), limit&&(i==up));
		}
		else
		{
			if(abs(pre-i)>=2)
			{
				ans += dfs(pos-1, i, sta&&(i==0), limit&&(i==up));
			}
		}
	}
	if(!limit&&pre!=0) dp[pos][pre] = ans;
	return ans;
}

ll slove(int x)
{
	int pos = 0;
	while(x)
	{
		a[pos++] = x%10;
		x/=10;
	}
	return dfs(pos-1, 0, 1, true);
}

int main()
{
	memset(dp, -1, sizeof(dp));
	scanf("%lld%lld", &l, &r);
	printf("%lld\n", slove(r) - slove(l-1));
	return 0;
}
\end{lstlisting}

\subsection{区间DP}
\subsubsection{51Nod 1021 石子合并}
\begin{lstlisting}
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int, int> P;
const int maxn = 1e5+5;
const int inf = 0x3f3f3f3f;
const int mod = 1e9+7;
const double PI = acos(-1);

int n;
int num[105];
int sum[105];
int dp[105][105];
int main()
{
	memset(dp, inf, sizeof(dp));
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>num[i];
		sum[i] = sum[i-1]+num[i];
		dp[i][i] = 0;
	}

	for(int len=1;len<=n;len++)
	{
		for(int i=1;i<=n-len+1;i++)
		{
			int end = i+len-1;
			for(int j=i;j<end;j++)
			{
				dp[i][end] = min(dp[i][end], dp[i][j] + dp[j+1][end]+sum[end]-sum[i-1]);
			}
		}
	}
	cout<<dp[1][n]<<endl;
	return 0;
}

\end{lstlisting}

\subsection{最长公共递增子序列}
\begin{lstlisting}
/*
*  最长公共递增子序列 O(n^2)
*  f记录路径,DP记录长度, 用a对b扫描,逐步最优化。
*/
const int N = 1010;

int f[N][N], dp[N];

int gcis(int a[], int la, int b[], int lb, int ans[])
{   //  a[1...la], b[1...lb]
	int i, j, k, mx;
	memset(f, 0, sizeof(f));
	memset(dp, 0, sizeof(dp));
	for (i = 1; i <= la; i++)
	{
		memcpy(f[i], f[i-1], sizeof(f[0]));
		for (k = 0, j = 1; j <= lb; j++)
		{
			if (b[j - 1] < a[i - 1] && dp[j] > dp[k])
			{
				k = j;
			}
			if (b[j - 1] == a[i - 1] && dp[k] + 1 > dp[j])
			{
				dp[j] = dp[k] + 1,
				f[i][j] = i * (lb + 1) + k;
			}
		}
	}
	for (mx = 0, i = 1; i <= lb; i++)
	{
		if (dp[i] > dp[mx])
		{
			mx = i;
		}
	}
	for (i = la * lb + la + mx, j = dp[mx]; j; i = f[i / (lb + 1)][i % (lb + 1)], j--)
	{
		ans[j - 1] = b[i % (lb + 1) - 1];
	}
	return dp[mx];
}
\end{lstlisting}

\subsection{最长公共子序列}
\begin{lstlisting}
const int N = 1010;

int a[N][N];

int LCS(const char *s1, const char *s2)
{   //  s1:0...m, s2:0...n
	int m = (int)strlen(s1), n = (int)strlen(s2);
	int i, j;
	a[0][0] = 0;
	for (i = 1; i <= m; ++i)
	{
		a[i][0] = 0;
	}
	for (i = 1; i <= n; ++i)
	{
		a[0][i] = 0;
	}
	for (i = 1; i <= m; ++i)
	{
		for (j = 1; j <= n; ++j)
		{
			if (s1[i - 1] == s2[j - 1])
			{
				a[i][j] = a[i - 1][j - 1] + 1;
			}
			else if (a[i - 1][j] > a[i][j - 1])
			{
				a[i][j]= a[i - 1][j];
			}
			else
			{
				a[i][j] = a[i][j - 1];
			}
		}
	}
	return a[m][n];
}
\end{lstlisting}

\subsection{最长有序子序列}
\begin{lstlisting}
int n;
int a[maxn]; // 原数组
int s[maxn]; // 记录LIS
int LIS()
{
	int top = 0;
	for(int i=0;i<n;i++)
	{
		int pos = upper_bound(s, s+top, a[i])-s;
		s[pos] = a[i];
		top = max(top, pos+1);
	}
	return top;
}
\end{lstlisting}

\begin{lstlisting}
/*
*  递增（默认）
*  递减 
*  非递增
*  非递减 (1)>= && <  (2)<  (3)>=
*/
const int MAXN = 1001;

int a[MAXN], f[MAXN], d[MAXN];   //  d[i] 用于记录 a[0...i] 以 a[i] 结尾的最大长度

int bsearch(const int *f, int size, const int &a)
{
	int l = 0, r = size - 1;
	while (l <= r)
	{
		int mid = (l + r) / 2;
		if (a > f[mid - 1] && a <= f[mid])  //  (1)
		{
			return mid; 
		}
		else if (a < f[mid])
		{
			r = mid - 1;
		}
		else
		{
			l = mid + 1;
		}
	}
	return -1;
}

int LIS(const int *a, const int &n)
{
	int i, j, size = 1;
	f[0] = a[0];
	d[0] = 1;
	for (i = 1; i < n; ++i)
	{
		if (a[i] <= f[0])               //  (2)
		{
			j = 0;
		}
		else if (a[i] > f[size - 1])    //  (3)
		{
			j = size++;
		}
		else
		{
			j = bsearch(f, size, a[i]);
		}
		f[j] = a[i];
		d[i] = j + 1;
	}
	return size;
}

int main()
{
	int i, n;
	while (scanf("%d", &n) != EOF)
	{
		for (i = 0; i < n; ++i)
		{
			scanf("%d", &a[i]);
		}
		printf("%d\n", LIS(a, n));      // 求最大递增 / 上升子序列(如果为最大非降子序列,只需把上面的注释部分给与替换)
	}
	return 0;
}
\end{lstlisting}





\section{字符串}
\subsection{KMP}
\begin{lstlisting}
// 能够获得t在s中出现的所有位置

#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> P;
const int maxn = 1e6+5;
const int inf = 0x3f3f3f3f;
const int mod = 1e9+7;
const double PI = acos(-1);


char s[maxn], t[maxn];
int ne[maxn];
int ls, lt;

void init()
{
	scanf("%s", s+1);
	scanf("%s", t+1);
	ls = strlen(s+1);
	lt = strlen(t+1);
}

void get_ne()
{
	int j = 0;
	for(int i=2;i<=lt;i++)
	{
		while(j && t[i]!=t[j+1])
			j = ne[j];
		if(t[i]==t[j+1])j++;
		ne[i] = j;
	}
}

void kmp()
{
	int j=0;
	vector<int> v;
	for(int i=1;i<=ls;i++)
	{
		while(j>0 && s[i]!=t[j+1])j = ne[j];
		if(s[i]==t[j+1])j++;
		if(j==lt)
		{
			v.push_back(i-lt+1);
			j = ne[j];
		}
	}
	for(auto x : v)printf("%d\n", x);
}

int main()
{
	init();
	get_ne();
	kmp();
	return 0;
}
\end{lstlisting}

\subsection{EXKMP}
\begin{lstlisting}
int nxt[maxn], extend[maxn];
char s[maxn], t[maxn];

void getNext()
{
	int n = strlen(t);
	nxt[0] = n;
	int a=0, p=0;
	for(int i=1;i<n;i++)
	{
		if(i>=p || i+nxt[i-a]>=p)
		{
			if(i>=p)p=i;
			while(p<n && t[p]==t[p-i])p++;
			nxt[i] = p-i;
			a=i;
		}
		else
			nxt[i] = nxt[i-a];
	}
}

void getExtend()
{
	int n = strlen(s), m = strlen(t);
	int a=0, p=0;
	getNext();
	for(int i=0;i<n;i++)
	{
		if(i>=p || i+nxt[i-a]>=p)
		{
			if(i>=p)p=i;
			while(p<n && p-i<m && s[p]==t[p-i])p++;
			extend[i] = p-i;
			a=i;
		}
		else
			extend[i] = nxt[i-a];
	}
}

int main()
{
	scanf("%s", s);
	scanf("%s", t);
	getExtend();
	int lens = strlen(s), lent = strlen(t);
	for(int i=0;i<lent;i++)
		printf("%d ", nxt[i]);
	printf("\n");
	for(int i=0;i<lens;i++)
		printf("%d ", extend[i]);
	printf("\n");
	return 0;
}
\end{lstlisting}

\subsection{字符串Hash}
\subsubsection{自然溢出}
\begin{lstlisting}
typedef long long ll;
typedef unsigned long long ull;
#define maxn 1005
struct My_Hash
{
	ull base=131;
	ull p[maxn],ha[maxn];
	void Insert(char s[])
	{
		int len=strlen(s+1);
		p[0]=1,ha[0]=0;
		for(int i=1;i<=len;i++)
		{
			p[i]=p[i-1]*base;
			ha[i]=ha[i-1]*base+(ull)s[i];
		}
	}
	
	ull gethash(int l,int r)
	{
		return (ull)ha[r]-ha[l-1]*p[r-l+1];
	}
}S;
int main()
{
	char s[maxn];
	cin>>s+1;
	S.Insert(s);
	int T;
	cin>>T;
	while(T--)
	{
		int l,r;
		cin>>l>>r;
		cout<<S.gethash(l,r)<<endl;
	}
	return 0;
}
\end{lstlisting}


\subsection{字典树Trie}
\begin{lstlisting}
int tree[maxn][30]; //字典树，有maxn个结点，30表示字符集的大小，比如小写字母就26个
int isend[maxn]; //表示结点i是否为某个串的结尾
int tot; //节点数

void insert(char *s)
{
	// 根节点为0号结点
	int root=0, len=strlen(s);
	for(int i=0;i<len;i++)
	{
		// pos是指当前字符应该为root的哪一个儿子
		int pos = s[i]-'a';
		// 如果不存在，则新创建
		if(!tree[root][pos])
			tree[root][pos] = ++tot;
		// root往下走
		root = tree[root][pos];
	}
	// 标记当前编号的结点是某个字符串的结尾
	isend[root] = 1;
}

int find(char *s)
{
	int root=0, len=strlen(s);
	for(int i=0;i<len;i++)
	{
		int pos = s[i]-'a';
		root = tree[root][pos];
		// 不存在则返回0
		if(!root)return 0;
	}
	return 1;
}
\end{lstlisting}

\subsection{Manacher}
\begin{lstlisting}
char s[maxn];
char t[2*maxn];
int p[2*maxn];
int manacher()
{
	int len = strlen(s);
	// 预处理字符串
	int l=0;
	t[l++] = '$';
	t[l++] = '#';
	for(int i=0;i<len;i++)
	{
		t[l++] = s[i];
		t[l++] = '#';
	}
	t[l] = '@';
	int id = 0, mx = 0;
	int maxlen = 1;
	for(int i=0;i<l;i++)
	{
		// 预设p[i]的值
		p[i] = mx>i ? min(p[2*id-i], mx-i) : 1;
		// 朴素算法向左右拓展，因为处理后的字符串头和尾都是特殊字符，所以不会越界
		while(t[i+p[i]] == t[i-p[i]])p[i]++;
		// 能否更新mx
		if(mx < p[i]+i)
		{
			mx = p[i]+i;
			id = i;
		}
		// 更新最长回文子串的长度
		if(maxlen < p[i]-1)
			maxlen = p[i]-1;
	}
	return maxlen;
}
\end{lstlisting}

\subsection{最小表示法}
\begin{lstlisting}
int getmin()
{
	int i=0, j=1, k=0, n=strlen(s);
	while(i<n && j<n && k<n)
	{
		int t = s[(i+k)%n]-s[(j+k)%n];
		if(!t)
			k++;
		else
		{
			if(t>0)
				i += k+1;
			else
				j += k+1;
			if(i==j)
				j++;
			k=0;
		}
	}
	return min(i, j);
}
\end{lstlisting}

\subsection{最大表示法}
\begin{lstlisting}
int getmax()
{
	int i=0, j=1, k=0, n=strlen(s);
	while(i<n && j<n && k<n)
	{
		int t = s[(i+k)%n]-s[(j+k)%n];
		if(!t)
			k++;
		else
		{
			if(t<0)
				i += k+1;
			else
				j += k+1;
			if(i==j)
				j++;
			k=0;
		}
	}
	return min(i, j);
}
\end{lstlisting}

\section{数学}
\subsection{欧拉函数}
定义：
欧拉函数phi(x)代表小于等于x的数中和x互质的数的个数(小于显然只对1成立)， 比如说小于等于9的数中与9互质的有1,2,4,5,7,8,则phi(9)=6.以phi(x)表示小于等于x的数中与x互质的数的个数可以这样得到：$ phi(x)=x\ast(1-1/p_1)\ast(1-1/p_2)\ast(1-1/ p_3)\cdots\ast(1-1/p_n) $其中p1,p2,p3….pn是x的所有质因数，每个质因数只使用一次，使用上述公式，则phi(9)=9*(1-1/3)=6.
\newline
\newline
特性 :
1.若a为质数,$ phi[a]=a-1 $ ;
\newline
2.若a为质数,$ b \% a=0,phi[a\ast b]=phi[b]\ast a
$
\newline
3.若a,b互质,$ phi[a\ast b]=phi[a]\ast phi[b] $(当a为质数时,$ if b mod a!=0 ,phi[a\ast b]=phi[a]\ast phi[b] $)
\newline
4.若p为质数，$ phi(p^k) == p^k - p^{k-1} == (p-1)\ast p^{k-1} $
\newline
5.当n>2时，phi(n)是偶数
\newline
6.phi(1)=1; （具体情况看题目，有时题目会要求为0)
\newline
\newline
欧拉筛法：
欧拉筛法的原理如下，观察phi(x)的求解式子，首先令phi(x)=x,然后仿照素数筛法，如果x能被2,3,5,7….这些素数筛到(即素数prime是x的因子)，则执行phi(x)=phi(x)*(1-1/prime)
\newline
\newline
\begin{lstlisting}
// 埃拉托斯特尼筛求欧拉函数值
const int maxn = 1000000;
int phi[maxn+1];
bool isPrime[maxn+1];
void Eular()
{
	for(int i=1;i<=maxn;i++) phi[i]=i;
	memset(isPrime,true,sizeof(isPrime));
	isPrime[0]=isPrime[1]=false;
	phi[1]=1;
	for(int i=2;i<=maxn;i++)
	{
		// i是质数
		if(isPrime[i])
		{
			for(int j=i;j<=maxn;j+=i)
			{
				// i与i的倍数都更新一遍
				isPrime[j]=false;
				phi[j] -= phi[j]/i;   // phi(x)=phi(x)*(1-1/prime) = phi(x) - phi(x)/prime
			}
		}
	}
}


// 欧拉筛求欧拉函数，时间复杂度接近O(n)
const int maxn = 1100000;
int num = 0;
int phi[maxn+1];
int prime[maxn+1];
int flag[maxn+1];

void eular()
{
	memset(flag, 0, sizeof(flag));
	phi[1]=1;//1要特判
	for (int i=2;i<=maxn;i++)
	{
		if (flag[i]==0)//这代表i是质数
		{
			prime[++num]=i;
			phi[i]=i-1;
		}
		for (int j=1;j<=num&&prime[j]*i<=maxn;j++)//经典的欧拉筛写法
		{
			flag[i*prime[j]]=1;//先把这个合数标记掉
			if(i%prime[j]==0)
			{
				phi[i*prime[j]]=phi[i]*prime[j];//若prime[j]是i的质因子，则根据计算公式，i已经包括i*prime[j]的所有质因子
				break;//经典欧拉筛的核心语句，这样能保证每个数只会被自己最小的因子筛掉一次
			}
			else phi[i*prime[j]]=phi[i]*phi[prime[j]];//利用了欧拉函数是个积性函数的性质
		}
	}
}
\end{lstlisting}

\subsection{枚举约数}
\begin{lstlisting}
// 枚举约数(普通)
vector<int> factor(int n)
{
	vector<int> a;
	for(int i = 2; i*i <= n; i++){
		if((n%i)==0){
			a.push_back(i);
			if((n/i)!=i)a.push_back(n/i);//根号n的情况不要重复添加
		}
	}
	return a;
}

特殊例题：f(n)为n所有约数的和，给你一个数n,让你求从1到n中f(n)为偶数的数有多少个
#include <bits/stdc++.h>
#define ll long long
#define INF 0x3f3f3f3f

using namespace std;

int main()
{
	int t, cas = 1;
	long long n, sum;
	cin >> t;
	while(t--)
	{
		scanf("%lld", &n);
		sum = n;
		sum -= (int)sqrt(n);
		sum -= (int)sqrt(n/2);
		printf("Case %d: %lld\n", cas++, sum);
	}
	return 0;
}
\end{lstlisting}

\subsection{全错排}
\begin{lstlisting}
问题：n封信给n个人，问全都送错的可能性有多少种
#include<iostream>
#include<stdio.h>
using namespace std;
int main()
{
	long long int arr[21];
	int num,i;
	arr[1]=0; arr[2]=1;
	for(i=3;i<21;i++)
		arr[i]=(i-1)*(arr[i-1]+arr[i-2]);   // d[n]= (n-1)*( d[n-1] + d[n-2])
	while(scanf("%d",&num)!=EOF)
	{
		cout<<arr[num]<<endl;
	}
	return 0;
}
\end{lstlisting}

\subsection{唯一分解定理}
算术基本定理可表述为：任何一个大于1的自然数N,如果N不为质数，那么N可以唯一分解成有限个质数的乘积$ N=P_1^{a_1} * P_2^{a_2} * P_3^{a_3}\cdots P_n^{a_n} $，这里P1<P2<P3......<Pn均为质数，其中指数ai是正整数。
\newline
\newline
(1)一个大于1的正整数N，如果它的标准分解式为: $ N = P_{1}^{a_1}P_{2}^{a_2}\cdots P_{n}^{a_n} $ ,那么它的正因数个数为 $ \sigma_{0}(N) = (1+a_1)(1+a_2)\cdots(1+a_n) $ 
\newline
\newline
(2)它的全体正因数之和为
$$ \sigma_{1}(N)=(1+p_1+p_{1}^{2}+\cdots+p_{1}^{a_1})(1+p_1+p_{2}^{2}+\cdots+p_{2}^{a_2})\cdots(1+p_n+p_{n}^{2}+\cdots+p_{n}^{a_n})
$$
当$ \sigma_{1}(N)=2N $时就称N为完全数

\subsubsection{例题一}
求出有几种边长为整数，面积等于a的矩形，且矩形的短边不小于b
\begin{lstlisting}
//考点：素数筛选 + 唯一分解定理
#include <bits/stdc++.h>
#define ll long long
#define INF 0x3f3f3f3f

using namespace std;

const int MAX = 1e6 + 10; // 边长
int prime[MAX], k; // k为全局变量，指向最后一个素数的后一个单元
bool isPrime[MAX];

// 素数筛选
void Prime()
{
	k = 0;
	memset(isPrime, true, sizeof(isPrime));
	isPrime[1] = false; // 1不是素数
	for(int i = 2; i < MAX; i++)
	{
		if(isPrime[i])
		{
			prime[k++] = i;
			for(int j = 2 ; i * j < MAX ; j++)
			{
				isPrime[i * j] = false;
			}
		}
	}
}

// 唯一分解定理找n的因子个数(N的因子个数 M = (1 + a1)*(1 + a2)*(1 + a3)*...*(1 + an))
long long solve(long long n)
{
	long long ans = 0, sum = 1;
	for(long long i = 0; i < k && prime[i]*prime[i] <= n; i++)
	{
		if(n % prime[i] == 0) // 从小到大寻找素数因子
		{
			ans = 0;
			while(n % prime[i] == 0) // 计算素数因子次数
			{
				ans++;
				n /= prime[i];
			}
			sum *= (1 + ans);
		}
	}
	if(n > 1) sum *= 2; // 如果处理到最后n还不是1，则最后剩下的一定是个素数
	return sum;
}

int main()
{
	Prime();
	int t, x = 0;
	long long ab, a, num;
	scanf("%d", &t);
	while(t--)
	{
		x++;
		scanf("%lld%lld", &ab, &a);
		if(ab < a * a)
		{
			printf("Case %d: 0\n", x);
			continue;
		}
		num = solve(ab); // 获得因子数(一个数的因子包括他本身)
		num /= 2;        // 因子对数
		for(long long i = 1 ; i < a ; i++)
		{
			if(ab % i == 0) num--; //将边小于a的情况减去
		}
		printf("Case %d: %lld\n", x, num);
	}
	return 0;
}
\end{lstlisting}

\subsubsection{例题二}
给你一个数$ x=b^p $,求p的最大值
$$ x=p_{1}^{x_1}\ast P_{2}^{x_2}\ast\cdots\ast P_{s}^{x_s} $$
题目要求$ x=b^p $,x只有一个因子的p次幂构成
如果$ x=12=2^2\ast 3^1 $,要让$ x=b^p $, 即12应该是$ 12=12^1 $
所以$ p=gcd(x_1,x_2,x_3,\cdots,x_s); $
比如：$ 24=2^3\ast 3^1 $,p应该是gcd(3, 1)=1, 即$ 24=24^1 $
	 $ 324=3^4\ast 2^2 $,p应该是gcd(4, 2)=2, 即$ 324=18^2 $
本题有一个坑，就是x可能为负数，如果x为负数的话，$ x=b^q $, q必须是奇数，所以将x转化为正数求得的解如果是偶数的话必须将其循环除2直到出现奇数
\begin{lstlisting}
#include <bits/stdc++.h>
using namespace std;

const int maxn=1e6+5;   // 卡内存
bool isprime[maxn];
int prime[maxn], psize=0;

// 素数筛选
void getPrimes()
{
	memset(isprime, true, sizeof(isprime));
	isprime[0] = isprime[1] = false;
	for (int i = 2; i < maxn; i++) if (isprime[i])
	{
		prime[psize++] = i;
		for(int j = 2; i * j < maxn; j++)
			isprime[i*j] = false;
	}
}

// 辗转相除
int gcd(int a, int b)
{
	return b == 0 ? a : gcd(b, a%b);
}

int main()
{
	int t, cas = 1;
	long long n;
	getPrimes();
	scanf("%d", &t);
	while (t--)
	{
		scanf("%lld", &n);
		int f = 0;
		if(n < 0)
		{
			n = - n;
			f = 1;
		}
		int res, ans = 0;
		for(int i = 0 ; i < psize && prime[i] * prime[i] <= n ; i++)
		{
			if(n % prime[i] == 0)
			{
				res = 0;
				while(n % prime[i] == 0)
				{
					res++;
					n /= prime[i];
				}
				if(ans == 0)
					ans = res;
				else
					ans = gcd(ans, res);
			}
		}
		if(n > 1) ans = gcd(ans, 1); // 如果分解完后剩下的n大于1，则剩下的一定是一个素数
		if(f == 1)
		{
			while(ans % 2 == 0)
				ans /= 2; // 如果n为负数且最后算出来指数为偶数，则循环除2直到变为奇数
		}
		printf("Case %d: %d\n", cas++, ans);
	}
	return 0;
}
\end{lstlisting}

\subsection{快速幂}
\begin{lstlisting}
typedef long long ll;
ll pow(ll x,ll n,ll mod)
{
	ll res=1;
	while(n>0)
	{
		if(n&1)	
		{
			res=res*x;
			res=res%mod;
		}
		x=x*x;
		x=x%mod;
		n>>=1;
	}
	return res;	
}

例题：给你一个n，一个k，求n^k的结果的前三位与后三位
//考点：快速幂取模(可获得后三位) + 数论运算(取前三位)

/**
* 设10^w=n^k，两边同时取log10，那么w=k*log10(n)。
* 再设x=(int)w（w的整数部分），y=w-x（w的小数部分），那么10^w=10^(x+y)=10^x*10^y=n^k；
* 由于10^x是10的倍数，那么10^y=n^k/10^x，因为0<y<1,所以10^y为一位数，即最前边那一位，所以求出y来
*/

#include <bits/stdc++.h>
#define ll long long
#define INF 0x3f3f3f3f

using namespace std;

// 快速幂取模
ll pow_mod(ll a, ll b, ll mod)
{
	int ans = 1;
	int base = a % mod;
	while(b){
		if(b & 1) ans = (ans*base) % mod;
		base = (base*base) % mod;
		b >>= 1;
	}
	return ans;
}

int main()
{
	ll n, k;
	ll ans1, ans2;
	int t, cas = 1;
	scanf("%d", &t);
	while(t--)
	{
		scanf("%lld%lld", &n, &k);
		ans2 = pow_mod(n, k, 1000);   // 取后三位
		double w = k*log10(n);
		w = w-(ll)w;
		ll ans1=(ll)(pow(10,w)*100);  // 取前三位
		printf("Case %d: %lld %03lld\n", cas++, ans1, ans2);   // 后三位要补前导零
	}
	return 0;
}
\end{lstlisting}

\subsection{欧拉降幂}
定理：
\newline
欧拉定理：若gcd(a, p) = 1, 则$ a^{p}\equiv a^{b\%\varphi(P)}(mod\quad P) $，其中gcd(a, p) = 1。
\newline
拓展欧拉定理：假设a为任意数，b和m为正整数，且$ b>\varphi(m) $，a和m不一定要互质，那么有如下公式：
\newline
$$
a^b \equiv
\left\{
\begin{array}{lcl}
	a^{bMod\phi(m)} & &\qquad gcd(a,m)=1 \\
	a^b & &\qquad gcd(a,m)\ne 1\bigwedge b<\phi(m)\quad (Mod\quad m) \\
	a^{bMod\phi(m)+\phi(m)} & &\qquad gcd(a,m)\ne 1\bigwedge b \ge\phi(m)
\end{array}
\right.
$$

\subsubsection{例题一}
\begin{lstlisting}
/*
Given A,B,C, You should quickly calculate the result of A^B mod C. (1<=A,C<=1000000000,1<=B<=10^1000000).（求(a^b)%c,其中b非常大,是个大数）
*/
#include <cstdio>
#include <iostream>
#include <cstring>
#include <cmath>
using namespace std;
typedef long long ll;
const int MAX=1000100;
ll  fastPow(ll  a,ll b,ll mod)
{
	ll ans=1;
	a %= mod;
	while(b)
	{
		if(b&1)
		{
			ans = (ans*a)%mod;
		}
		b >>= 1;
		a = (a*a)%mod;
	}
	return ans;
}
ll  eulerFunction(ll x)
{
	ll eulerNumbers = x;
	for(ll i = 2; i*i <= x; i++)
	{
		if(x % i == 0)
		{
			eulerNumbers = eulerNumbers / i * (i-1);
			while(x % i == 0)
			{
				x /= i;
			}
		}
	}
	if(x > 1)
	{
		eulerNumbers = eulerNumbers / x * (x-1);
	}
	return eulerNumbers;
}
ll eulerDropPow(ll a,char b[],ll c)
{
	ll eulerNumbers = eulerFunction(c);
	ll descendingPower=0;
	for(ll i=0,len = strlen(b); i<len; ++i)
	{
		descendingPower=(descendingPower*10+b[i]-'0') % eulerNumbers;
	}
	descendingPower += eulerNumbers;
	return fastPow(a,descendingPower,c);
}
int main()
{
	ll a,c;
	char b[MAX];
	while(~scanf("%lld%s%lld",&a,b,&c))
	{
		printf("%lld\n",eulerDropPow(a,b,c));
	}
	return 0;
}
\end{lstlisting}


\subsection{广义欧拉降幂}
\subsubsection{例题一}
给定a和K以及m，试求出
$$
a^{a^{a^{\cdots}}}mod\;m
$$
其中共K层幂塔。其中a，K和m小于等于1e6
\newline
1.首先，当a = 1或者b = 0时特判，得出答案为 1\%m
\newline
2.本题中b = f(a, k-1,INF)，如果$ a \ge phi(m) $，那么显然b一定大于phi(m)，即满足拓展欧拉定理中第3种情况
\newline
3.如果k = 1，则b = f(a,k-1,INF) = 1，此时只需判断phi(m)是否大于1即可判断当然情况符合拓展欧拉定理第3还是第2种情况
\newline
4.剩下的情况我们就可以通过递归来判断b是否大于phi(m)，因为若$ b \ge phi(m) $，那么$ \log_ab\ge log_a{phi(m)} $
\newline
\begin{lstlisting}
#include<cstdio>
#include<cmath>
typedef long long ll;
const int N = 1e6+10;
ll qpow(ll a,ll b,ll m){
	ll res = 1;
	while(b){
		if(b&1) res = res*a%m;
		a = a*a%m;
		b >>= 1;
	}
	return res;
}
int v[N],primes[N],phi[N];
int init(){
	int cnt = 0;
	for(int i = 2;i < N;i++){
		if(!v[i]){
			primes[cnt++] = i;
			v[i] = i;
			phi[i] = i-1;
		}
		for(int j = 0;j < cnt;j++){
			if(primes[j] > v[i] || primes[j]*i >= N)
				break;
			v[i*primes[j]] = primes[j];
			phi[i*primes[j]] = phi[i]*(i%primes[j] ? primes[j]-1 : primes[j]);
		}
	}
}
ll gcd(ll a,ll b){
	if(b == 0) return a;
	return gcd(b,a%b);
}
bool check(ll a,ll b,ll p){
	if(b == 0) return p <= 1;	//f(a,0,p) = 1
	if(a >= p) return true;//f(a,b,INF) > p
	return check(a,b-1,log(p)/log(a)); 
}
ll f(ll a,ll b,ll m){
	if(m == 1) return 0;		//递归终止条件1,此时之后答案恒为0 
	if(b <= 1) return qpow(a,b,m);//递归终止条件2 
	ll ph = phi[m];
	//	printf("%lld\n",ph);
	if(gcd(a,m) == 1) return qpow(a,f(a,b-1,ph),m);	//欧拉定理 
	if(check(a,b-1,ph)) return qpow(a,f(a,b-1,ph)+ph,m);//拓展欧拉定理情况1 
	return qpow(a,f(a,b-1,ph),m); 		//拓展欧拉定理情况2 
}
ll a,b,m;
int t;
int main(){
	scanf("%d",&t);
	init();
	while(t--){
		scanf("%lld%lld%lld",&a,&b,&m);
		printf("%lld\n",f(a,b,m));
	}
	return 0;
}
\end{lstlisting}

\subsubsection{例题二}
给定长度为n的正整数序列和模数m，q次询问区间[l,r]累乘幂\%m的答案。$ n,q\ne10^5,m,a_i\ne10^9 $。
$$
w_1^{(w_2^{(w_3^{(\cdots^{w_m})})})}
$$
\begin{lstlisting}
#include <bits/stdc++.h>
#define aaa cout<<233<<endl;
#define endl '\n'
#define pb push_back
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef long double ld; 
// mt19937 rnd(time(0));
const int inf = 0x3f3f3f3f;//1061109567 > 1e9
const ll linf = 0x3f3f3f3f3f3f3f3f;
const double eps = 1e-7;
const double pi = 3.14159265358979;
const int maxn = 1e5 + 5;
const int maxm = 1e3 + 5;
const int mod = 1e9 + 7;

ll a[maxn];

inline ll modulo(ll x, ll mod){return x < mod ? x : x % mod + mod;}
inline ll pow_(ll a, ll b, ll p)
{
	ll ret = 1;
	while(b)
	{
		if(b & 1)ret = modulo(ret * a, p);
		a = modulo(a * a, p);
		b >>= 1;
	}
	return ret;
}
unordered_map<ll, ll> phi_;
inline ll phi(ll x)
{
	if(phi_[x])return phi_[x];
	ll ans = x;
	ll t = x;
	for(ll i = 2; i * i <= x; ++i)
	{
		if(x % i == 0)
		{
			ans = ans / i * (i - 1);
			while(x % i == 0)x /= i;
		}
	}
	if(x > 1)ans = ans / x * (x - 1);
	phi_[t] = ans;
	return ans;
}
//这里根据题意来更改，k表示共有k个指数
ll f(ll a, ll b, ll k, ll p)
{
	if(p == 1)return 1;
	if(k == 0)return 1;
	return pow_(a, f(a, a, k - 1, phi(p)), p);
}
ll f(ll l, ll r, ll p)
{
	if(p == 1)return 1;
	if(l == r + 1)return 1;
	return pow_(a[l], f(l + 1, r, phi(p)), p);
}

int main()
{
	// double pp = clock();
	// freopen("233.in", "r", stdin);
	// freopen("233.out", "w", stdout);
	ios_base::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);

	ll n, m;
	cin >> n >> m;
	for(int i = 1; i <= n; ++i)cin >> a[i];
	int q; cin >> q;
	while(q--)
	{
		ll l, r; cin >> l >> r;
		cout << f(l, r, m) % m << endl;
	}

	// cout << endl << (clock() - pp) / CLOCKS_PER_SEC << endl;
	return 0;
}
\end{lstlisting}

\subsubsection{例题三}
求
$$
n^{(n-1)^{(n-2)^{\cdots^1}}}
$$
\begin{lstlisting}
#include <bits/stdc++.h>
#define aaa cout<<233<<endl;
#define endl '\n'
#define pb push_back
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef long double ld; 
// mt19937 rnd(time(0));
const int inf = 0x3f3f3f3f;//1061109567 > 1e9
const ll linf = 0x3f3f3f3f3f3f3f3f;
const double eps = 1e-7;
const double pi = 3.14159265358979;
const int maxn = 1e5 + 5;
const int maxm = 1e3 + 5;
const int mod = 1e9 + 7;


inline ll modulo(ll x, ll mod){return x < mod ? x : x % mod + mod;}
inline ll pow_(ll a, ll b, ll p)
{
	ll ret = 1;
	while(b)
	{
		if(b & 1)ret = modulo(ret * a, p);
		a = modulo(a * a, p);
		b >>= 1;
	}
	return ret;
}
unordered_map<ll, ll> phi_;
inline ll phi(ll x)
{
	if(phi_[x])return phi_[x];
	ll ans = x;
	ll t = x;
	for(ll i = 2; i * i <= x; ++i)
	{
		if(x % i == 0)
		{
			ans = ans / i * (i - 1);
			while(x % i == 0)x /= i;
		}
	}
	if(x > 1)ans = ans / x * (x - 1);
	phi_[t] = ans;
	return ans;
}

// ll f(ll l, ll r, ll p)
// {
//     if(p == 1)return 1;
//     if(l == r + 1)return 1;
//     return pow_(a[l], f(l + 1, r, phi(p)), p);
// }

ll f(ll a, ll p)
{
	if(p == 1)return 1;
	if(a == 1)return 1;
	return pow_(a, f(a - 1, phi(p)), p);
}

int main()
{
	// double pp = clock();
	// freopen("233.in", "r", stdin);
	// freopen("233.out", "w", stdout);
	ios_base::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);

	ll n, m;
	while(cin >> n >> m)cout << f(n, m) % m << endl;

	// cout << endl << (clock() - pp) / CLOCKS_PER_SEC << endl;
	return 0;
}
\end{lstlisting}

\subsection{逆序数}
\begin{lstlisting}
/*
*  也可以用树状数组做
*  a[0...n-1] cnt=0; call: MergeSort(0, n)
*/
const int N = 1010;
int a[N];
int c[N];
int cnt = 0;

void MergeSort(int l, int r)
{
	int mid, i, j, tmp;
	if (r > l + 1)
	{
		mid = (l + r) / 2;
		MergeSort(l, mid);
		MergeSort(mid, r);
		tmp = l;
		for (i = l, j = mid; i < mid && j < r;)
		{
			if (a[i] > a[j])
			{
				c[tmp++] = a[j++];
				cnt += mid - i;
			}
			else
			{
				c[tmp++] = a[i++];
			}
		}
		if (j < r)
		{
			for (; j < r; ++j)
			{
				c[tmp++] = a[j];
			}
		}
		else
		{
			for (; i < mid; ++i)
			{
				c[tmp++]=a[i];
			}
		}
		for (i = l; i < r; ++i)
		{
			a[i] = c[i];
		}
	}
	return ;
}
\end{lstlisting}

\subsection{无序序列变有序的最少交换次数}
\subsubsection{相邻元素交换}
\begin{lstlisting}
\\ 等于逆序数个数
\end{lstlisting}

\subsubsection{任意元素交换}
\begin{lstlisting}
*
*  交换任意两数的本质是改变了元素位置，
*  故建立元素与其目标状态应放置位置的映射关系
*/
int getMinSwaps(vector<int> &A)
{
	//  排序
	vector<int> B(A);
	sort(B.begin(), B.end());
	map<int, int> m;
	int len = (int)A.size();
	for (int i = 0; i < len; i++)
	{
		m[B[i]] = i;    //  建立每个元素与其应放位置的映射关系
	}

	int loops = 0;      //  循环节个数
	vector<bool> flag(len, false);
	//  找出循环节的个数
	for (int i = 0; i < len; i++)
	{
		if (!flag[i])
		{
			int j = i;
			while (!flag[j])
			{
				flag[j] = true;
				j = m[A[j]];    //  原序列中j位置的元素在有序序列中的位置
			}
			loops++;
		}
	}
	return len - loops;
}
\end{lstlisting}

\subsection{GCD}
\subsubsection{非递归}
\begin{lstlisting}
int gcd(int x, int y)
{
	if (!x || !y)
	{
		return x > y ? x : y;
	}

	for (int t; t = x % y, t; x = y, y = t) ;

	return y;
}
\end{lstlisting}

\subsubsection{递归}
\begin{lstlisting}
int gcd(int a, int b)
{ 
	return b==0 ? a : gcd(b, a%b); 
}
\end{lstlisting}

\subsection{EXGCD}
欧几里得是用来求a,b的最大公约数，那么扩展欧几里得不仅能求出a,b的最大公约数，还能求出满足ax+by=gcd(a,b)的一组可行解。
\begin{lstlisting}
/*
*  求x，y使得gcd(a, b) = a * x + b * y;
*/
int extgcd(int a, int b, int &x, int &y)
{
	if (b == 0)
	{
		x = 1;
		y = 0;
		return a;
	}
	int d = extgcd(b, a % b, x, y);
	int t = x;
	x = y;
	y = t - a / b * y;
	return d;
}
\end{lstlisting}
\subsubsection{例题}
例题：给出a,b,c,x1,x2,y1,y2，求满足ax+by+c=0，且$ x\in[x1,x2],y\in[y1,y2] $的整数解个数
\newline
\newline
先处理无解情况：
\newline
1、当a=0并且b=0，而$ c\neq 0 $时，显然无解；
当a=0,b=0，而c=0时，[x1,x2],[y1,y2]都为可行解，根据乘法原理，可行解的个数为(x2-x1+1)*(y2-y1+1);
\newline
\newline
2、当a=0 $ b\neq 0 $时：
此时即为求解by=c，则y=c/b，
如果c/b不是整数或c/b不在[y1,y2]的范围内，无解
否则[x1,x2]内全部整数都为可行解。
\newline
\newline
3、当b=0,$ a\neq 0 $时，同上。
\newline
\newline
4、若c不是gcd(a,b)的倍数，方程显然无解。
\begin{lstlisting}
#include <iostream>
#include <cmath>
#include <cstdio>
typedef ll longlong
using namespace std;

ll a,b,c,x1,x2,yy1,y2,x0,yy0; // 全局变量
inline ll cmin(const ll &x,const ll &y) {return x<y?x:y;}
inline ll cmax(const ll &x,const ll &y) {return x>y?x:y;}

ll gcd(ll a,ll b)
{
	if (b==0) return a;
	return gcd(b,a % b);
}

void exgcd(ll a,ll b)
{
	if (b==0){x0=1;yy0=0;return;}
	exgcd(b,a%b);
	ll t=x0;x0=yy0;yy0=t-a/b*yy0;
	return;
}

int main()
{
	cin >> a >> b >> c;
	cin >> x1 >> x2;
	cin >> yy1 >> y2;
	c=-c;
	if (c<0) {a=-a;b=-b;c=-c;}
	if (a<0) {a=-a;ll t=x1;x1=-x2;x2=-t;}
	if (b<0) {b=-b;ll t=yy1;yy1=-y2;y2=-t;}
	if (a==0 && b==0)
	{
		if (c==0)
		{
			cout << (x2-x1+1)*(y2-yy1+1) << endl;
			return 0;
		}
		cout << "0" << endl; return 0;
	}
	else if (a==0)
	{
		if (c % b ==0)
			if (c/b<=y2 && c/b>=yy1) {cout << x2-x1+1 << endl; return 0;}
		cout << "0" << endl; return 0;
	}
	else if (b==0)
	{
	if (c%a==0)
		if (c/a<=x2 && c/a>=x1) {cout << y2-yy1+1 << endl; return 0;}
	cout << "0" << endl; return 0;
	}

	ll d=gcd(a,b);
	if (c%d!=0){cout << "0" << endl; return 0;}

	a=a/d;b=b/d;c=c/d;
	exgcd(a,b);
	x0=x0*c;yy0=yy0*c;

	double tx2=x2,tx1=x1,tx0=x0,ta=a,tb=b,tc=c,ty1=yy1,ty2=y2,ty0=yy0;
	ll down1=floor(((tx2-tx0)/tb)),down2=floor(((ty0-ty1)/ta));
	ll r=cmin(down1,down2);
	ll up1=ceil(((tx1-tx0)/tb)),up2=ceil(((ty0-ty2)/ta));
	ll l=cmax(up1,up2);
	if (r<l) cout << "0" << endl;
	else cout << r-l+1 << endl;
	return 0;
}
\end{lstlisting}

\subsection{逆元}
对于正整数a和m，如果有$ ax\equiv 1(mod\quad m) $, 那么把这个同余方程中x的最小正整数解叫做a模m的逆元。
\newline
\newline
\subsubsection{拓展欧几里得法}
\begin{lstlisting}
// 扩展欧几里得(求a对于mod的逆元, 要求a与mod互素)
ll exgcd(ll a, ll b, ll &x, ll &y)
{
	//求2对于1e9+7的逆元就是 exgcd(2, 1e9+7, x, y),其中x的值就是inv2，
	if (b == 0)
	{
		x = 1;
		y = 0;
		return a;
	}
	ll r = exgcd(b, a % b, x, y);
	ll t = x % mod;
	x = y % mod;
	y = ((t - a / b * y) % mod + mod) % mod;
	return r;
}
\end{lstlisting}

\subsubsection{费马小定理法}
\begin{lstlisting}
// 费马小定理(求a对于mod的逆元，要求mod为素数)
ll power_mod(ll a, ll b, ll mod)
{
	ll ans = 1;
	while (b)
	{
		if (b & 1) ans = ans * a % mod;
		a = a * a % mod;
		b >>= 1;
	}
	return ans;
}
inv2 = power_mod(a, mod - 2, mod);
\end{lstlisting}

\subsection{中国剩余定理}
中国剩余定理给出了以下的一元线性同余方程:
$$
(S):
\left\{
\begin{array}{rcl}
	x\equiv a_1 & &\qquad(mod\quad m_1) \\
	x\equiv a_2 & &\qquad(mod\quad m_2) \\
	& &\vdots \\
	x\equiv a_n & &\qquad(mod\quad m_n)
\end{array}
\right.
$$
中国剩余定理说明：假设整数$ m_1, m_2, \cdots ,m_n $两两互质，则对任意的整数：$ a_1, a_2, \cdots ,a_n $方程组(S)有解，并且通解可以通过如下方式构造得到：
\newline
\begin{lstlisting}
//n个方程：x=a[i](mod m[i]) (0<=i<n)
ll china(int n, ll *a, ll *m){
	ll M = 1, ret = 0;
	for(int i = 0; i < n; i ++) M *= m[i];
	for(int i = 0; i < n; i ++){
		ll w = M / m[i];
		ret = (ret + w * inv(w, m[i]) * a[i]) % M;
	}
	return (ret + M) % M;
}
\end{lstlisting}
\subsubsection{例题}
人自出生起就有体力，情感和智力三个生理周期，分别为23，28和33天。一个周期内有一天为峰值，在这一天，人在对应的方面（体力，情感或智力）表现最好。通常这三个周期的峰值不会是同一天。现在给出三个日期，分别对应于体力，情感，智力出现峰值的日期。然后再给出一个起始日期，要求从这一天开始，算出最少再过多少天后三个峰值同时出现。
\newline
\newline
分析：假设x为这个天数，n1为第一个周期出现的日期，p1为其周期，以此类推，则如果同时出现峰值，则：
\newline
\newline
$ x=n_1 + k_1\ast p_1 $
\newline
$ x=n_2 + k_2\ast p_2 $
\newline
$ x=n_3 + k_3\ast p_3 $
\newline
\newline
两侧同时取余p有：
\newline
$ x\%p_1=n_1\%p_1 $ 即 $ x\%p_1=a_1 $
\newline
$ x\%p_2=n_2\%p_2 $ 即 $ x\%p_2=a_2 $
\newline
$ x\%p_3=n_3\%p_3 $ 即 $ x\%p_3=a_3 $
\newline
\newline
$ p_1=23, p_2=27, p_3=33 $两两互质

\begin{lstlisting}
#include<cstdio>
typedef long long ll;
const int N = 100000 + 5;
void ex_gcd(ll a, ll b, ll &x, ll &y, ll &d){
	if (!b) {d = a, x = 1, y = 0;}
	else{
		ex_gcd(b, a % b, y, x, d);
		y -= x * (a / b);
	}
}

ll inv(ll t, ll p){//如果不存在，返回-1 
	ll d, x, y;
	ex_gcd(t, p, x, y, d);
	return d == 1 ? (x % p + p) % p : -1;
}

ll china(int n, ll *a, ll *m){//中国剩余定理 
	ll M = 1, ret = 0;
	for(int i = 0; i < n; i ++) M *= m[i];
	for(int i = 0; i < n; i ++){
		ll w = M / m[i];
		ret = (ret + w * inv(w, m[i]) * a[i]) % M;
	}
	return (ret + M) % M;
}

int main(){
	ll p[3], r[3], d, ans, MOD = 21252;
	int cas = 0;
	p[0] = 23; p[1] = 28; p[2] = 33;
	while(~scanf("%lld%lld%lld%lld", &r[0], &r[1], &r[2], &d) && (~r[0] || ~r[1] || ~r[2] || ~d)){
		ans = ((china(3, r, p) - d) % MOD + MOD) % MOD;
		printf("Case %d: the next triple peak occurs in %I64d days.\n", ++cas, ans ? ans : 21252);
	}
	return 0;
}
\end{lstlisting}

\subsection{拓展中国剩余定理}
\begin{lstlisting}
//m1,m2, ... ,mn两两不保证互质
#include<cstdio>
#include<algorithm>
using namespace std;
typedef long long ll;
typedef pair<ll, ll> PLL;
PLL linear(ll A[], ll B[], ll M[], int n) {//求解A[i]x = B[i] (mod M[i]),总共n个线性方程组 
	ll x = 0, m = 1;
	for(int i = 0; i < n; i ++) {
		ll a = A[i] * m, b = B[i] - A[i]*x, d = gcd(M[i], a);
		if(b % d != 0)  return PLL(0, -1);//答案不存在，返回-1 
		ll t = b/d * inv(a/d, M[i]/d)%(M[i]/d);
		x = x + m*t;
		m *= M[i]/d;
	}
	x = (x % m + m ) % m;
	return PLL(x, m);//返回的x就是答案，m是最后的lcm值 
}
\end{lstlisting}






\subsection{素数}
\subsubsection{判断小于MAXN的数是否为素数}
\begin{lstlisting}
/*
*  素数筛选，判断小于MAXN的数是不是素数
*  notprime是一张表，false表示是素数，true表示不是
*/
const int MAXN = 1000010;
bool notprime[MAXN];

void init()
{
	memset(notprime, false, sizeof(notprime));
	notprime[0] = notprime[1] = true;
	for (int i = 2; i < MAXN; i++)
	{
		if (!notprime[i])
		{
			if (i > MAXN / i)   //  阻止后边i * i溢出（或者i,j用long long)
			{
				continue;
			}
			//  直接从i * i开始就可以，小于i倍的已经筛选过了
			for (int j = i * i; j < MAXN; j += i)
			{
				notprime[j] = true;
			}
		}
	}
}
\end{lstlisting}

\subsubsection{埃式筛法}
\begin{lstlisting}
const int MAX = 1e6 + 10; 
int prime[MAX], k; // k为全局变量，指向最后一个素数的后一个单元
bool isPrime[MAX];
void Prime()
{
	k = 0;
	memset(isPrime, true, sizeof(isPrime));
	isPrime[1] = false; // 1不是素数
	for(int i = 2; i < MAX; i++)
	{
		if(isPrime[i])
		{
			prime[k++] = i;
			for(int j = 2 ; i * j < MAX ; j++)
			{
				isPrime[i * j] = false;
			}
		}
	}
}
\end{lstlisting}

\subsubsection{线性筛法}
\begin{lstlisting}
/*
*  素数筛选，查找出小于等于MAXN的素数
*  prime[0]存素数的个数
*/

const int MAXN = 100000;
int prime[MAXN + 1];

void getPrime()
{
	memset(prime, 0, sizeof(prime));
	for (int i = 2; i <= MAXN; i++)
	{
		if (!prime[i])
		{
			prime[++prime[0]] = i;
		}
		for (int j = 1; j <= prime[0] && prime[j] <= MAXN / i; j++)
		{
			prime[prime[j] * i] = 1;
			if (i % prime[j] == 0)
			{
				break;
			}
		}
	}
}
\end{lstlisting}

\subsubsection{Miller Rabin}
\begin{lstlisting}
/*
*  随机素数测试（伪素数原理）
*  CALL: bool res = miller(n);
*  快速测试n是否满足素数的“必要”条件，出错概率极低
*  对于任意奇数n > 2和正整数s，算法出错概率≤2^(-s)
*/

int witness(int a, int n)
{
	int x, d = 1;
	int i = ceil(log(n - 1.0) / log(2.0)) - 1;
	for (; i >= 0; i--)
	{
		x = d;
		d = (d * d) % n;
		if (d == 1 && x != 1 && x != n - 1)
		{
			return 1;
		}
		if (((n - 1) & (1 << i)) > 0)
		{
			d = (d * a) % n;
		}
	}
	return (d == 1 ? 0 : 1);
}

int miller(int n, int s = 50)
{
	if (n == 2)     //  质数返回1
		return 1;
	if (n % 2 == 0) //  偶数返回0
		return 0;
	int j, a;
	for (j = 0; j < a; j++)
	{
		a = rand() * (n - 2) / RAND_MAX + 1;
		//  rand()只能随机产生[0, RAND_MAX)内的整数
		//  而且这个RAND_MAX只有32768直接%n的话是永远
		//  也产生不了[RAND_MAX, n)之间的数
		if (witness(a, n))
		{
			return 0;
		}
	}
	return 1;
}
\end{lstlisting}

\subsubsection{求1e11内的素数个数}
\begin{lstlisting}
// 方法一
// O(n^(3/4))
ll f[340000],g[340000],n;
void init()
{
	ll i,j,m;
	for(m=1;m*m<=n;++m)f[m]=n/m-1;
	for(i=1;i<=m;++i)g[i]=i-1;
	for(i=2;i<=m;++i)
	{
		if(g[i]==g[i-1])continue;
		for(j=1;j<=min(m-1,n/i/i);++j)
		{
			if(i*j<m)f[j]-=f[i*j]-g[i-1];
			else f[j]-=g[n/i/j]-g[i-1];
		}
		for(j=m;j>=i*i;--j)g[j]-=g[j/i]-g[i-1];
	}
}
int main()
{
	while(scanf("%I64d",&n)!=EOF)
	{
		init();
		cout<<f[1]<<endl;
	}
	return 0;
}
\end{lstlisting}

\begin{lstlisting}
// 方法二
// O(n^(2/3))
const int N = 5e6 + 2;
bool np[N];
int prime[N], pi[N];
int getprime()
{
	int cnt = 0;
	np[0] = np[1] = true;
	pi[0] = pi[1] = 0;
	for(int i = 2; i < N; ++i)
	{
		if(!np[i]) prime[++cnt] = i;
		pi[i] = cnt;
		for(int j = 1; j <= cnt && i * prime[j] < N; ++j)
		{
			np[i * prime[j]] = true;
			if(i % prime[j] == 0)   break;
		}
	}
	return cnt;
}
const int M = 7;
const int PM = 2 * 3 * 5 * 7 * 11 * 13 * 17;
int phi[PM + 1][M + 1], sz[M + 1];
void init()
{
	getprime();
	sz[0] = 1;
	for(int i = 0; i <= PM; ++i)  phi[i][0] = i;
	for(int i = 1; i <= M; ++i)
	{
		sz[i] = prime[i] * sz[i - 1];
		for(int j = 1; j <= PM; ++j)
			phi[j][i] = phi[j][i - 1] - phi[j / prime[i]][i - 1];
	}
}
int sqrt2(LL x)
{
	LL r = (LL)sqrt(x - 0.1);
	while(r * r <= x)   ++r;
	return int(r - 1);
}
int sqrt3(LL x)
{
	LL r = (LL)cbrt(x - 0.1);
	while(r * r * r <= x)   ++r;
	return int(r - 1);
}
LL getphi(LL x, int s)
{
	if(s == 0)  return x;
	if(s <= M)  return phi[x % sz[s]][s] + (x / sz[s]) * phi[sz[s]][s];
	if(x <= prime[s]*prime[s])   return pi[x] - s + 1;
	if(x <= prime[s]*prime[s]*prime[s] && x < N)
	{
		int s2x = pi[sqrt2(x)];
		LL ans = pi[x] - (s2x + s - 2) * (s2x - s + 1) / 2;
		for(int i = s + 1; i <= s2x; ++i) ans += pi[x / prime[i]];
		return ans;
	}
	return getphi(x, s - 1) - getphi(x / prime[s], s - 1);
}
LL getpi(LL x)
{
	if(x < N)   return pi[x];
	LL ans = getphi(x, pi[sqrt3(x)]) + pi[sqrt3(x)] - 1;
	for(int i = pi[sqrt3(x)] + 1, ed = pi[sqrt2(x)]; i <= ed; ++i) 
		ans -= getpi(x / prime[i]) - i + 1;
	return ans;
}
LL lehmer_pi(LL x)
{
	if(x < N)   return pi[x];
	int a = (int)lehmer_pi(sqrt2(sqrt2(x)));
	int b = (int)lehmer_pi(sqrt2(x));
	int c = (int)lehmer_pi(sqrt3(x));
	LL sum = getphi(x, a) +(LL)(b + a - 2) * (b - a + 1) / 2;
	for (int i = a + 1; i <= b; i++)
	{
		LL w = x / prime[i];
		sum -= lehmer_pi(w);
		if (i > c) continue;
		LL lim = lehmer_pi(sqrt2(w));
		for (int j = i; j <= lim; j++) sum -= lehmer_pi(w / prime[j]) - (j - 1);
	}
	return sum;
}
int main()
{
	init();
	LL n;
	while(~scanf("%lld",&n))
	{
		printf("%lld\n",lehmer_pi(n));
	}
	return 0;
}
\end{lstlisting}



\subsection{组合数}
\begin{lstlisting}
int com(int n, int r)   //  return C(n, r)
{
	if (n - r > r)
	{
		r = n - r;      //  C(n, r) = C(n, n - r)
	}
	int i, j, s = 1;
	for (i = 0, j = 1; i < r; ++i)
	{
		s *= (n - i);
		for (; j <= r && s % j == 0; ++j)
		{
			s /= j;
		}
	}
	return s;
}
\end{lstlisting}

\subsection{阶乘长度}
\begin{lstlisting}
#define PI 3.1415926

int main()
{
	int n, a;
	while (~scanf(“%d", &n))
	{
		a = (int)((0.5 * log(2 * PI * n) + n * log(n) - n) / log(10));
		printf("%d\n", a + 1);
	}
	return 0;
}
\end{lstlisting}

\subsection{全排列}
\begin{lstlisting}
#define MAX_N 10
int n;                      //  共n个数
int rcd[MAX_N];             //  记录每个位置填的数
int used[MAX_N];            //  标记数是否用过
int num[MAX_N];             //  存放输入的n个数

void full_permutation(int l)
{
	int i;
	if (l == n)
	{
		for (i = 0; i < n; i++)
		{
			printf("%d", rcd[i]);
			if (i < n-1)
			{
				printf(" ");
			}
		}
		printf("\n");
		return ;
	}
	for (i = 0; i < n; i++)         //  枚举所有的数(n个),循环从开始
	if (!used[i])
	{                           //  若num[i]没有使用过, 则标记为已使用
		used[i] = 1;
		rcd[l] = num[i];        //  在l位置放上该数
		full_permutation(l+1);  //  填下一个位置
		used[i] = 0;            //  清标记
	}
}
\end{lstlisting}

\subsection{求斐波那契第N项}
\begin{lstlisting}
/*
*  求斐波那契数列第N项，模MOD
*/
#define mod(a, m) ((a) % (m) + (m)) % (m)
const int MOD = 1e9 + 9;
struct MATRIX
{
	long long a[2][2];
};

MATRIX a;
long long f[2];

void ANS_Cf(MATRIX a)
{
	f[0] = mod(a.a[0][0] + a.a[1][0], MOD);
	f[1] = mod(a.a[0][1] + a.a[1][1], MOD);
	return ;
}

MATRIX MATRIX_Cf(MATRIX a, MATRIX b)
{
	MATRIX ans;
	int k;
	for (int i = 0; i < 2; i++)
	{
		for (int j = 0; j < 2; j++)
		{
			ans.a[i][j] = 0;
			k = 0;
			while (k < 2)
			{
				ans.a[i][j] += a.a[k][i] * b.a[j][k];
				ans.a[i][j] = mod(ans.a[i][j], MOD);
				++k;
			}
		}
	}
	return ans;
}

MATRIX MATRIX_Pow(MATRIX a, long long n)
{
	MATRIX ans;
	ans.a[0][0] = 1;
	ans.a[1][1] = 1;
	ans.a[0][1] = 0;
	ans.a[1][0] = 0;
	while (n)
	{
		if (n & 1)
		{
			ans = MATRIX_Cf(ans, a);
		}
		n = n >> 1;
		a = MATRIX_Cf(a, a);
	}
	return ans;
}

int main()
{
	long long n;
	while (cin >> n)
	{
		if (n == 1)
		{
			cout << '1' << '\n';
			continue;
		}
		a.a[0][0] = a.a[0][1] = a.a[1][0] = 1;
		a.a[1][1] = 0;
		a = MATRIX_Pow(a, n - 2);
		ANS_Cf(a);
		cout << f[0] << '\n';
	}
	return 0;
}
\end{lstlisting}

\subsection{质因子}
\begin{lstlisting}
vector<int> primeFactorList;

void getPrimeFactor(int num)
{
	for(int i=2;i*i<=num;i++)
	{
		if(num%i==0)
		{
			primeFactorList.push_back(i);
			while(num%i==0) num=num/i;
		}
	}
	if(num>1) primeFactorList.push_back(num);
}
\end{lstlisting}

\subsection{公共因子数}
\begin{lstlisting}
//一串数字的公共因子数
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	ll n,gc;
	cin>>n;
	cin>>gc;
	n--;
	while(n--)
	{
		ll tmp;
		cin>>tmp;
		gc = __gcd(gc,tmp);
		if(gc==1)
		{
			cout<<"1"<<endl;
			return 0;
		}
	}
	ll ans =0;
	for(ll i=1;i*i<=gc;i++)
	{
		if(gc%i==0)
		{
			ans++;
			if(i*i!=gc) ans++;
		}
	}
	cout<<ans<<endl;
}
\end{lstlisting}

\subsection{除法分块}
\begin{lstlisting}
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
#define inf 0x3f3f3f3f
#define INF 0x3f3f3f3f3f3f3f3f
#define IO ios::sync_with_stdio(0)
typedef pair<int, int> P;
const int maxn = 2e5+5;
const ll mod = 1e9+7;
using namespace std;


ull cal(ull n)
{
	ull ans = 0;
	for(ull l=1, r; l<=n; l=r+1)
	{
		r = n/(n/l);
		ans += (n/l) * (l+r)*(r-l+1)/2;
	}
	return ans;
}
int main()
{
	IO;
	ull a, b;
	cin>>a>>b;
	cout<<cal(b) - cal(a-1)<<"\n";
	return 0;
}
\end{lstlisting}

\section{STL}
\subsection{vector}
\begin{lstlisting}
vector<int> s;      
//  定义一个空的vector对象，存储的是int类型的元素
vector<int> s(n);   
//  定义一个含有n个int元素的vector对象
vector<int> s(first, last); 
//  定义一个vector对象，并从由迭代器first和last定义的序列[first, last)中复制初值

s[i]                //  直接以下标方式访问容器中的元素
s.front()           //  返回首元素
s.back()            //  返回尾元素
s.push_back(x)      //  向表尾插入元素x
s.size()            //  返回表长
s.empty()           //  表为空时，返回真，否则返回假
s.pop_back()        //  删除表尾元素
s.begin()           //  返回指向首元素的随机存取迭代器
s.end()             //  返回指向尾元素的下一个位置的随机存取迭代器
s.insert(it, val)   //  向迭代器it指向的元素前插入新元素val
s.insert(it, n, val)//  向迭代器it指向的元素前插入n个新元素val
s.insert(it, first, last)   
//  将由迭代器first和last所指定的序列[first, last)插入到迭代器it指向的元素前面
s.erase(it)         //  删除由迭代器it所指向的元素
s.erase(first, last)//  删除由迭代器first和last所指定的序列[first, last)
s.reserve(n)        //  预分配缓冲空间，使存储空间至少可容纳n个元素
s.resize(n)         //  改变序列长度，超出的元素将会全部被删除，如果序列需要扩展（原空间小于n），元素默认值将填满扩展出的空间
s.resize(n, val)    //	改变序列长度，超出的元素将会全部被删除，如果序列需要扩展（原空间小于n），val将填满扩展出的空间
s.clear()           //  删除容器中的所有元素
s.swap(v)           //  将s与另一个vector对象进行交换
s.assign(first, last)	//  将序列替换成由迭代器first和last所指定的序列[first, last)，[first, last)不能是原序列中的一部分

//  要注意的是，resize操作和clear操作都是对表的有效元素进行的操作，但并不一定会改变缓冲空间的大小
//  vector上还定义了序列之间的比较操作运算符（>、<、>=、<=、==、!=），可以按照字典序比较两个序列。
\end{lstlisting}


\subsection{set}
\begin{lstlisting}
// 有序
set<int> s;
s.begin()       //  返回指向第一个元素的迭代器
s.clear()       //  清除所有元素
s.count()       //  返回某个值元素的个数
s.empty()       //  如果集合为空，返回true(真）
s.end()         //  返回指向最后一个元素之后的迭代器，不是最后一个元素
s.equal_range() //  返回集合中与给定值相等的上下限的两个迭代器
s.erase()       //  删除集合中的元素
s.find()        //  返回一个指向被查找到元素的迭代器
s.get_allocator()   //  返回集合的分配器
s.insert()      //  在集合中插入元素
s.lower_bound() //  返回指向大于（或等于）某值的第一个元素的迭代器
s.key_comp()    //  返回一个用于元素间值比较的函数
s.max_size()    //  返回集合能容纳的元素的最大限值
s.rbegin()      //  返回指向集合中最后一个元素的反向迭代器
s.rend()        //  返回指向集合中第一个元素的反向迭代器
s.size()        //  集合中元素的数目
s.swap()        //  交换两个集合变量
s.upper_bound() //  返回大于某个值元素的迭代器
s.value_comp()  //  返回一个用于比较元素间的值的函数

// 多重集合
multiset<int> s;
// 操作类似
\end{lstlisting}


\subsection{pair}
\begin{lstlisting}
pair<T1, T2> p1;
pair<T1, T2> p1(v1, v2);
p1.first;
p1.second;
p1 = make_pair(v1, v2);

vector<pair<int, int> > v;
sort(v.begin(), v.end()); //根据pair的first排序，从小到大
\end{lstlisting}


\subsection{stack}
\begin{lstlisting}
stack<int> s;
s.push(x);  //  入栈
s.pop();    //  出栈
s.top();    //  访问栈顶
s.empty();  //  当栈空时，返回true
s.size();   //  访问栈中元素个数
\end{lstlisting}


\subsection{queue}
\begin{lstlisting}
queue<int> q;
q.push(x);  //  入队列
q.pop();    //  出队列
q.front();  //  访问队首元素
q.back();   //  访问队尾元素
q.empty();  //  判断队列是否为空
q.size();   //  访问队列中的元素个数

//priority_queue（优先队列）。优先队列与队列的差别在于优先队列不是按照入队的顺序出队，而是按照队列中元素的优先权出队列（默认为大者优先，也可以通过指定算子来指定自己的优先顺序）。

priority_queue模版类有三个模版参数，第一个是元素类型，第二个是容器类型，第三个是比较算子。其中后两者都可以忽略，默认容器为vector，默认算子为less，即小的往前排，大的往后排（出队列时列尾元素先出队）。

priority_queue<int> q;
priority_queue<pair<int, int> > qq;	//  注意在两个尖括号之间一定要留空格，防止误判
priority_queue<int, vector<int>, greater<int> > qqq;//  定义小的先出队列

q.empty()     //  如果队列为空，则返回true，否则返回false
q.size()      //  返回队列中元素的个数
q.pop()       //  删除队首元素，但不返回其值
q.top()       //  返回具有最高优先级的元素值，但不删除该元素
q.push(item)  //  在基于优先级的适当位置插入新元素

//deque双端队列
#include<deque>
deque<int> dep;

deq.push_front(const T& x); //头插
deq.push_back(const T& x);	//尾插
deq.insert(iterator it, const T& x);	//任意位置

deq.pop_front();	//删除头部
deq.pop_back();		//删除尾部
deq.erase(iterator it);		//删除任意

deq[1]; // 并不会检查是否越界
deq.at(1); // 以上两者的区别就是 at 会检查是否越界，是则抛出 out of range 异常
deq.front();	//访问头部
deq.back();		//访问尾部
\end{lstlisting}


\subsection{map}
\begin{lstlisting}
map<T1, T2> mp;
mp[key] = value;
T2 value = mp[key];
mp.size();       //  返回元素个数
mp.empty();      //  判断是否为空
mp.clear();      //  清空所有元素
\end{lstlisting}


\subsection{bitset}
\begin{lstlisting}
const int MAXN = 32;

bitset<MAXN> bt;            //  bt 包括 MAXN 位，下标 0 ~ MAXN - 1，默认初始化为 0
bitset<MAXN> bt1(0xf);      //  0xf 表示十六进制数 f，对应二进制 1111，将 bt1 低 4 位初始化为 1
bitset<MAXN> bt2(012);      //  012 表示八进制数 12，对应二进制 1010，即将 bt2 低 4 位初始化为 1010
bitset<MAXN> bt3("1010");   //  将 bt3 低 4 位初始化为 1010

bt.any()        //  bt 中是否存在置为 1 的二进制位？
bt.none()       //  bt 中不存在置为 1 的二进制位吗？
bt.count()      //  bt 中置为 1 的二进制位的个数
bt.size()       //  bt 中二进制位的个数
bt[pos]         //  访问 bt 中在 pos 处的二进制位
bt.test(pos)    //  bt 中在 pos 处的二进制位是否为 1
bt.set()        //  把 bt 中所有二进制位都置为 1
bt.set(pos)     //  把 bt 中在 pos 处的二进制位置为 1
bt.reset()      //  把 bt 中所有二进制位都置为 0
bt.reset(pos)   //  把 bt 中在pos处的二进制位置为0
bt.flip()       //  把 bt 中所有二进制位逐位取反
bt.flip(pos)    //  把 bt 中在 pos 处的二进制位取反
bt[pos].flip()  //  同上
bt.to_ulong()   //  用 bt 中同样的二进制位返回一个 unsigned long 值
\end{lstlisting}


\subsection{algorithm}
\begin{lstlisting}
reverse(begin, end)	// 反转

unique(begin, end)	// 需排序，去除重复的相邻元素，常用于求不同元素个数
int n=unique(a, a+10)-a；

lower_bound(begin, end, value)	//返回指向第一个不小于给定值的元素的迭代器

upper_bound(begin, end, value)	//返回指向第一个大于给定值的元素的迭代器

next_permutation(array)	//一种排列的下一种排列
\end{lstlisting}



\section{计算几何}
\subsection{三角形面积}
\begin{lstlisting}
\\ 海伦公式
int p = (a+b+c)/2;
int s = sqrt(p * (p - a) * (p - b) * (p - c));

\\ 两边和夹角
\\ a, b为边, x为a和b的夹角
s = 0.5 * a * b * sin(x/90.0*acos(0));
\end{lstlisting}

\subsection{两圆面积交}
\begin{lstlisting}
const double PI = acos(-1);

struct circle
{
	double x, y, r;
};

// 计算圆心距
double dist(circle a, circle b)
{
	return sqrt((a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y));
}

double area(circle a, circle b)
{
	if((dist(a, b) + min(a.r, b.r)) <= max(a.r, b.r)) // 内含或重合
	{
		if(a.r < b.r)
			return PI*a.r*a.r;
		else
			return PI*b.r*b.r;
	}
	else if(dist(a, b) >= (a.r + b.r)) // 相切
	{
		return 0.0;
	}
	else
	{
		double length = dist(a, b);
		// 利用三角形余弦定理求圆心角
		double d1 = 2*acos((a.r*a.r+length*length-b.r*b.r)/(2*a.r*length));
		double d2 = 2*acos((b.r*b.r+length*length-a.r*a.r)/(2*b.r*length));
		// 利用圆心角求得扇形面积再减去三角形面积后两部分相加就是相交面积
		double area1 = a.r*a.r*d1/2 - a.r*a.r*sin(d1)/2;
		double area2 = b.r*b.r*d2/2 - b.r*b.r*sin(d2)/2;
		return area1 + area2;
	}
}
\end{lstlisting}

\subsection{矩形相交}
\begin{lstlisting}
//一.相交面积==白色
//这做法看起来思路简单但是很多坑

//应该是两个黑白相交面积之和-黑黑白相交面积，而不是-黑黑相交面积！(当时就wa在这)

//求相交面积先判断是否相交（即x1,x2大小与y1,y2大小）
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

struct CC{
	ll x1,x2,y1,y2;
};

CC jiao(CC a,CC b)//相交矩形的坐标，可能不存在
{
	CC c1;
	c1.x1 = max(a.x1,b.x1);
	c1.y1 = max(a.y1,b.y1);
	c1.x2 = min(a.x2,b.x2);
	c1.y2 = min(a.y2,b.y2);
	return c1;
}

int main()
{
	CC w,b1,b2;
	cin>>w.x1>>w.y1>>w.x2>>w.y2>>b1.x1>>b1.y1>>b1.x2>>b1.y2>>b2.x1>>b2.y1>>b2.x2>>b2.y2;
	CC j1 = jiao(w,b1);
	CC j2 = jiao(w,b2);
	CC j3 = jiao(j1,j2);
	ll s,s1,s2,s3;
	s= (w.x2-w.x1) * (w.y2-w.y1);//白色
	if(j1.x1>j1.x2 || j1.y1>j1.y2) s1 = 0;//不想交则为0
	else s1 = (j1.x2-j1.x1)*(j1.y2-j1.y1);
	if(j2.x1>j2.x2 || j2.y1>j2.y2) s2 = 0;//不想交则为0
	else s2 = (j2.x2-j2.x1)*(j2.y2-j2.y1);
	if(j3.x1>j3.x2 || j3.y1>j3.y2) s3 = 0;//不想交则为0
	else s3 = (j3.x2-j3.x1)*(j3.y2-j3.y1);

	if(s1+s2-s3 == s) cout<<"NO"<<endl;
	else cout<<"YES"<<endl;
	return 0;
}
\end{lstlisting}


\section{其它}
\subsection{数据类型范围}
\begin{tabular}{|c|c|}
	\hline 数据类型&范围\\
	\hline char&-128 - 127\\
	\hline int&2147483648 - 2147483647(十位)\\
	\hline long long&-9223372036854775808 - 9223372036854775807(大约十九位)\\
	\hline double&1.7 * 10\^308\\
	\hline
\end{tabular}

\subsection{头文件}
\begin{lstlisting}
//#include<stdio.h>
//#include<iostream>
//#include<queue>
//#include<algorithm>
//#include<cstring>
//#include<vector>
//#include<cmath>
//#include<string>
//#include<map>
//#include<set>
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define inf 0x3f3f3f3f
typedef pair<int, int> P;
const int maxn = 5e4+5;
const ll mod = 1e9+7;
\end{lstlisting}

\subsection{Vim配置}
\begin{lstlisting}
// open ~/.vimrc
syntax on
set nu ts=4 sw=4 mouse=a cin
colo desert

inoremap ' ''<ESC>i
inoremap " ""<ESC>i
inoremap ( ()<ESC>i
inoremap [ []<ESC>i
inoremap { {<CR>}<ESC>O
map <C-A> ggVG"+y
map <F5> :call CR()<CR>
func! CR()
exec "w"
exec "!g++ -O2 -g -std=c++11 -Wall % -o %<"
exec "! ./%<"   
endfunc
\end{lstlisting}

\subsection{输入挂}
\subsubsection{关闭同步}
\begin{lstlisting}
#define endl '\n'

ios::sync_whit_stdio(0);
cin.tie(0);
\end{lstlisting}

\subsubsection{IO}
\begin{lstlisting}
#include<cstdio>

inline void read(int &x) 	//看情况可去掉负数部分
{
	int t = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9') { if(ch == '-') t = -1; ch = getchar();}
	x = 0;
	while(ch >= '0' && ch <= '9'){ x=x*10+ch-'0'; ch = getchar(); } 
	x*=t;
}

void print(int i){
	if(i<10){
		putchar('0'+i);
		return ;
	}
	print(i/10);
	putchar('0'+i%10);
}
\end{lstlisting}

\subsection{C++大数}
\subsubsection{大数加法}
\begin{lstlisting}
string add(string a,string b)
{	//两数相加
	string res="";
	int i=1;
	string first="0";
	while(true) {
		int tai=a.size()-i;
		int tbi=b.size()-i;
		if(tai<0 && tbi<0)
			break;			//从两数最右边开始模拟加法运算直到两数都遍历完
		int ta,tb;
		if(tai<0)
			ta=0;	//如果没数则至为0
		else
			ta=a[tai]-'0';
		if(tbi<0)
			tb=0;	//如果没数则至为0
		else
			tb=b[tbi]-'0';
		int temp=ta+tb+first[0]-'0';	//相加 first保存上一个的进位信息
		first[0]=temp%10+'0';	//当前位是对10取余
		res=first+res;
		first[0]=temp/10+'0';	//进位是除10
		i++;
	}
	if(first!="0")
		res=first+res;	//如果进位还有则添加
	if(res[0]=='0' && res.size()>1)	//去除前导0
		res.erase(res.begin());
	return res;
}
\end{lstlisting}

\subsubsection{大数乘法}
\begin{lstlisting}
// 还需要配合大数加法
string mul(string a,string b) {
	if(b.size()==1) {	//如果b只有一位则使其分别相乘
		string res="";
		string first="0";
		int mb=b[0]-'0';
		for(int i=a.size()-1; i>=0; i--) {	//从最后开始依次计算
			int temp=(a[i]-'0') * mb + (first[0]-'0');
			first[0]=temp%10+'0';	//当前位
			res=first+res;
			first[0]=temp/10+'0';	//进位
		}
		if(first!="0") {
			res=first+res;	//处理进位
		}
		if(res[0]=='0' && res.size()>1)
			res.erase(res.begin());	//除去前导0
		return res;
		}
	//否则则把b拆分为一位
	string res="0";
	string zero="";
	for(int i=b.size()-1; i>=0; i--) {	//从b的最后一位开始
		string temp=mul(a,b.substr(i,1));	//计算当前为与a相乘
		res=add(res,temp+zero);	//在其后添加适当的0再与结果相加
		zero=zero+"0";
	}
	return res;
}
\end{lstlisting}

\subsubsection{整数转string}
\begin{lstlisting}
string inttostring(int m) {	//将整数转为string
	string res="";
	string temp="0";
	while(m) {
		temp[0]=m%10+'0';
		res=temp+res;
		m/=10;
	}
	if(res=="")
		res="0";
	return res;
}
\end{lstlisting}


\subsection{Java}
\begin{lstlisting}
valueOf(parament); 将参数转换为制定的类型

比如 int a=3;

BigInteger b=BigInteger.valueOf(a);

则b=3;

String s=”12345”;

BigInteger c=BigInteger.valueOf(s);

则c=12345;

// 常用函数
1.赋值：
BigInteger a=new BigInteger("1");
BigInteger b=BigInteger.valueOf(1);

2.运算：
① add(); 大整数相加 
BigInteger a=new BigInteger(“23”); 
BigInteger b=new BigInteger(“34”); 
a.add(b);

②subtract(); 相减 
③multiply(); 相乘 
④divide(); 相除取整 
⑤remainder(); 取余 
⑥pow(); a.pow(b)=a^b 
⑦gcd(); 最大公约数 
⑧abs(); 绝对值 
⑨negate(); 取反数 
⑩mod(); a.mod(b)=a%b=a.remainder(b); 

3.BigInteger构造函数： 
一般用到以下两种： 
BigInteger(String val); 
将指定字符串转换为十进制表示形式； 
BigInteger(String val,int radix); 
将指定基数的 BigInteger 的字符串表示形式转换为 BigInteger

4.基本常量： 
A=BigInteger.ONE 1 
B=BigInteger.TEN 10 
C=BigInteger.ZERO 0 

5.n.compareTo(BigInteger.ZERO)==0  //相当于n==0

6.if(a[i].compareTo(n)>=0 && a[i].compareTo(m)<=0)   // a[i]>=n && a[i]<=m

// 模板
import java.math.BigInteger;
import java.math.BigDecimal;
import java.util.Scanner;
import java.util.*;
import java.io.*;
public class Main {
	public static void main(String [] args){
		Scanner cin = new Scanner(System.in);
		BigInteger a, b;
		while(cin.hasNext())//相当于c语言中的scanf("%d", &n) != EOF
		{
			a = cin.nextBigInteger();
			b = cin.nextBigInteger();
			System.out.println(a.add(b));//大整数加法
			System.out.println(a.subtract(b));//大整数减法
			System.out.println(a.multiply(b));//大整数乘法
			System.out.println(a.divide(b));//大整数除法，取整
			System.out.println(a.remainder(b));//大整数取模
			System.out.println(a.abs());//对大整数a取绝对值
			int x = 0;
			System.out.println(a.pow(x));//大整数a的x次幂
			int y = 8;
			System.out.println(a.toString(y));//返回大整数a的p进制用字符串表现的形式
			System.out.println(a.toString());//返回大整数a的十进制用字符串表现的形式
			//大整数之间的比较
			if( a.compareTo(b) == 0 ) System.out.println("a == b"); //大整数a==b
			else if( a.compareTo(b) > 0 ) System.out.println("a > b"); //大整数a>b
			else if( a.compareTo(b) < 0 ) System.out.println("a < b"); //大整数a<b)
			
			BigDecimal c, d;
			c = cin.nextBigDecimal();
			d = cin.nextBigDecimal();
			System.out.println(c.add(d));//浮点数相加
			System.out.println(c.subtract(d));//浮点数相减
			System.out.println(c.multiply(d));//浮点数相乘
		}
	}
}

// 输入方式
int a = cin.nextInt();
String s = cin.nextLine();
double b = cin.nextDouble();
\end{lstlisting}

\subsection{二分答案}
\begin{lstlisting}
#include<bits/stdc++.h>
using namespace std;
int n,m,A;
int  l,r,mid,a[100005];
int  total ,cnt;
bool judge(int mid)
{
	int num = 0;
	int l = a[0];
	for(int i =1;i<n;i++)
	{
		if(a[i]-l<mid) num++;
		else  l = a[i];
		if(num>A) return false;
	}
	return true;
}

int main()
{
	while(cin>>n>>m)
	{
		A = n-m;//最大剩余牛栏数
		l =r = 0;
		int  ans;
		for(int i = 0;i<n;i++)
		{
			cin>>a[i];
			r = max(r,a[i]);
		}
		sort(a,a+n);
		while(l<=r)
		{
			mid = (l+r)/2;
			total = cnt = 0;
			if(judge(mid))
			{
				l = mid+1;
				ans = mid;
			}//若此答案可行，从mid+1 ~ r区间继续查找（更大答案），即修改左界l=mid +1
			else
			{
				r = mid -1;  //反之，若此答案不可行，从l ~ mid-1区间查找（合理答案），即修改左界l=mid -1
				//ans = mid;
			}
		}
		cout<<ans<<endl;
	}
	return 0;
}
\end{lstlisting}